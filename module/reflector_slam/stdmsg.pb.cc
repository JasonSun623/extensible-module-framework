// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stdmsg.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "stdmsg.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace stdmsg {

namespace {

const ::google::protobuf::Descriptor* Position_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Position_reflection_ = NULL;
const ::google::protobuf::Descriptor* Orentation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Orentation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Pose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Pose_reflection_ = NULL;
const ::google::protobuf::Descriptor* Velocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Velocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Laser_Scan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Laser_Scan_reflection_ = NULL;
const ::google::protobuf::Descriptor* Laser_Scan_Laser_Config_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Laser_Scan_Laser_Config_reflection_ = NULL;
const ::google::protobuf::Descriptor* Global_Plan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Global_Plan_reflection_ = NULL;
const ::google::protobuf::Descriptor* Data_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Data_reflection_ = NULL;
const ::google::protobuf::Descriptor* String_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  String_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaserList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaserList_reflection_ = NULL;
const ::google::protobuf::Descriptor* Block_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Block_reflection_ = NULL;
const ::google::protobuf::Descriptor* Net_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Net_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_stdmsg_2eproto() {
  protobuf_AddDesc_stdmsg_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "stdmsg.proto");
  GOOGLE_CHECK(file != NULL);
  Position_descriptor_ = file->message_type(0);
  static const int Position_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, z_),
  };
  Position_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Position_descriptor_,
      Position::default_instance_,
      Position_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _has_bits_[0]),
      -1,
      -1,
      sizeof(Position),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _internal_metadata_),
      -1);
  Orentation_descriptor_ = file->message_type(1);
  static const int Orentation_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, roll_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, pitch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, yaw_),
  };
  Orentation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Orentation_descriptor_,
      Orentation::default_instance_,
      Orentation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, _has_bits_[0]),
      -1,
      -1,
      sizeof(Orentation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Orentation, _internal_metadata_),
      -1);
  Pose_descriptor_ = file->message_type(2);
  static const int Pose_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, orentation_),
  };
  Pose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Pose_descriptor_,
      Pose::default_instance_,
      Pose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, _has_bits_[0]),
      -1,
      -1,
      sizeof(Pose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, _internal_metadata_),
      -1);
  Velocity_descriptor_ = file->message_type(3);
  static const int Velocity_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, v_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, w_),
  };
  Velocity_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Velocity_descriptor_,
      Velocity::default_instance_,
      Velocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, _has_bits_[0]),
      -1,
      -1,
      sizeof(Velocity),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, _internal_metadata_),
      -1);
  Laser_Scan_descriptor_ = file->message_type(4);
  static const int Laser_Scan_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, config_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, ranges_rssi_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, intensities_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, robot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, steer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, annotation_),
  };
  Laser_Scan_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Laser_Scan_descriptor_,
      Laser_Scan::default_instance_,
      Laser_Scan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, _has_bits_[0]),
      -1,
      -1,
      sizeof(Laser_Scan),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan, _internal_metadata_),
      -1);
  Laser_Scan_Laser_Config_descriptor_ = Laser_Scan_descriptor_->nested_type(0);
  static const int Laser_Scan_Laser_Config_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, angle_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, angle_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, angle_increment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, range_max_),
  };
  Laser_Scan_Laser_Config_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Laser_Scan_Laser_Config_descriptor_,
      Laser_Scan_Laser_Config::default_instance_,
      Laser_Scan_Laser_Config_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, _has_bits_[0]),
      -1,
      -1,
      sizeof(Laser_Scan_Laser_Config),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Laser_Scan_Laser_Config, _internal_metadata_),
      -1);
  Global_Plan_descriptor_ = file->message_type(5);
  static const int Global_Plan_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, goal_reached_),
  };
  Global_Plan_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Global_Plan_descriptor_,
      Global_Plan::default_instance_,
      Global_Plan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, _has_bits_[0]),
      -1,
      -1,
      sizeof(Global_Plan),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Global_Plan, _internal_metadata_),
      -1);
  Data_descriptor_ = file->message_type(6);
  static const int Data_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, seq_),
  };
  Data_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Data_descriptor_,
      Data::default_instance_,
      Data_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, _has_bits_[0]),
      -1,
      -1,
      sizeof(Data),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, _internal_metadata_),
      -1);
  String_descriptor_ = file->message_type(7);
  static const int String_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(String, str_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(String, seq_),
  };
  String_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      String_descriptor_,
      String::default_instance_,
      String_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(String, _has_bits_[0]),
      -1,
      -1,
      sizeof(String),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(String, _internal_metadata_),
      -1);
  LaserList_descriptor_ = file->message_type(8);
  static const int LaserList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserList, scans_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserList, seq_),
  };
  LaserList_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LaserList_descriptor_,
      LaserList::default_instance_,
      LaserList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserList, _has_bits_[0]),
      -1,
      -1,
      sizeof(LaserList),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserList, _internal_metadata_),
      -1);
  Block_descriptor_ = file->message_type(9);
  static const int Block_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Block, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Block, input_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Block, input_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Block, output_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Block, output_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Block, dll_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Block, object_),
  };
  Block_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Block_descriptor_,
      Block::default_instance_,
      Block_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Block, _has_bits_[0]),
      -1,
      -1,
      sizeof(Block),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Block, _internal_metadata_),
      -1);
  Net_descriptor_ = file->message_type(10);
  static const int Net_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Net, block_),
  };
  Net_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Net_descriptor_,
      Net::default_instance_,
      Net_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Net, _has_bits_[0]),
      -1,
      -1,
      sizeof(Net),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Net, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_stdmsg_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Position_descriptor_, &Position::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Orentation_descriptor_, &Orentation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Pose_descriptor_, &Pose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Velocity_descriptor_, &Velocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Laser_Scan_descriptor_, &Laser_Scan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Laser_Scan_Laser_Config_descriptor_, &Laser_Scan_Laser_Config::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Global_Plan_descriptor_, &Global_Plan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Data_descriptor_, &Data::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      String_descriptor_, &String::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LaserList_descriptor_, &LaserList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Block_descriptor_, &Block::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Net_descriptor_, &Net::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_stdmsg_2eproto() {
  delete Position::default_instance_;
  delete Position_reflection_;
  delete Orentation::default_instance_;
  delete Orentation_reflection_;
  delete Pose::default_instance_;
  delete Pose_reflection_;
  delete Velocity::default_instance_;
  delete Velocity_reflection_;
  delete Laser_Scan::default_instance_;
  delete Laser_Scan_reflection_;
  delete Laser_Scan_Laser_Config::default_instance_;
  delete Laser_Scan_Laser_Config_reflection_;
  delete Global_Plan::default_instance_;
  delete Global_Plan_reflection_;
  delete Data::default_instance_;
  delete Data_reflection_;
  delete String::default_instance_;
  delete String_reflection_;
  delete LaserList::default_instance_;
  delete LaserList_reflection_;
  delete Block::default_instance_;
  delete Block_reflection_;
  delete Net::default_instance_;
  delete Net_reflection_;
}

void protobuf_AddDesc_stdmsg_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014stdmsg.proto\022\006stdmsg\"4\n\010Position\022\014\n\001x\030"
    "\001 \002(\001:\0010\022\014\n\001y\030\002 \002(\001:\0010\022\014\n\001z\030\003 \001(\001:\0010\"\?\n\n"
    "Orentation\022\017\n\004roll\030\001 \001(\001:\0010\022\020\n\005pitch\030\002 \001"
    "(\001:\0010\022\016\n\003yaw\030\003 \002(\001:\0010\"R\n\004Pose\022\"\n\010positio"
    "n\030\001 \002(\0132\020.stdmsg.Position\022&\n\norentation\030"
    "\002 \002(\0132\022.stdmsg.Orentation\"&\n\010Velocity\022\014\n"
    "\001v\030\001 \002(\001:\0010\022\014\n\001w\030\002 \002(\001:\0010\"\307\002\n\nLaser_Scan"
    "\022/\n\006config\030\001 \002(\0132\037.stdmsg.Laser_Scan.Las"
    "er_Config\022\016\n\006ranges\030\002 \003(\002\022\023\n\013ranges_rssi"
    "\030\n \003(\002\022\023\n\013intensities\030\003 \003(\002\022\032\n\004pose\030\005 \002("
    "\0132\014.stdmsg.Pose\022\033\n\005robot\030\006 \002(\0132\014.stdmsg."
    "Pose\022\r\n\005steer\030\t \001(\001\022\016\n\003seq\030\007 \001(\005:\0010\022\024\n\na"
    "nnotation\030\010 \001(\t:\000\032`\n\014Laser_Config\022\021\n\tang"
    "le_min\030\001 \002(\002\022\021\n\tangle_max\030\002 \002(\002\022\027\n\017angle"
    "_increment\030\003 \002(\002\022\021\n\trange_max\030\005 \002(\002\"R\n\013G"
    "lobal_Plan\022\032\n\004path\030\001 \003(\0132\014.stdmsg.Pose\022\016"
    "\n\003seq\030\002 \001(\005:\0010\022\027\n\014goal_reached\030\003 \001(\005:\0010\""
    "&\n\004Data\022\016\n\004data\030\001 \001(\014:\000\022\016\n\003seq\030\002 \001(\005:\0010\""
    "\'\n\006String\022\r\n\003str\030\001 \001(\014:\000\022\016\n\003seq\030\002 \001(\005:\0010"
    "\">\n\tLaserList\022!\n\005scans\030\001 \003(\0132\022.stdmsg.La"
    "ser_Scan\022\016\n\003seq\030\002 \001(\005:\0010\"z\n\005Block\022\014\n\004nam"
    "e\030\001 \002(\t\022\r\n\005input\030\002 \003(\t\022\022\n\ninput_type\030\003 \003"
    "(\t\022\016\n\006output\030\004 \003(\t\022\023\n\013output_type\030\005 \003(\t\022"
    "\013\n\003dll\030\006 \002(\t\022\016\n\006object\030\007 \002(\t\"#\n\003Net\022\034\n\005b"
    "lock\030\001 \003(\0132\r.stdmsg.Block", 985);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "stdmsg.proto", &protobuf_RegisterTypes);
  Position::default_instance_ = new Position();
  Orentation::default_instance_ = new Orentation();
  Pose::default_instance_ = new Pose();
  Velocity::default_instance_ = new Velocity();
  Laser_Scan::default_instance_ = new Laser_Scan();
  Laser_Scan_Laser_Config::default_instance_ = new Laser_Scan_Laser_Config();
  Global_Plan::default_instance_ = new Global_Plan();
  Data::default_instance_ = new Data();
  String::default_instance_ = new String();
  LaserList::default_instance_ = new LaserList();
  Block::default_instance_ = new Block();
  Net::default_instance_ = new Net();
  Position::default_instance_->InitAsDefaultInstance();
  Orentation::default_instance_->InitAsDefaultInstance();
  Pose::default_instance_->InitAsDefaultInstance();
  Velocity::default_instance_->InitAsDefaultInstance();
  Laser_Scan::default_instance_->InitAsDefaultInstance();
  Laser_Scan_Laser_Config::default_instance_->InitAsDefaultInstance();
  Global_Plan::default_instance_->InitAsDefaultInstance();
  Data::default_instance_->InitAsDefaultInstance();
  String::default_instance_->InitAsDefaultInstance();
  LaserList::default_instance_->InitAsDefaultInstance();
  Block::default_instance_->InitAsDefaultInstance();
  Net::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_stdmsg_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_stdmsg_2eproto {
  StaticDescriptorInitializer_stdmsg_2eproto() {
    protobuf_AddDesc_stdmsg_2eproto();
  }
} static_descriptor_initializer_stdmsg_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Position::kXFieldNumber;
const int Position::kYFieldNumber;
const int Position::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Position::Position()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Position)
}

void Position::InitAsDefaultInstance() {
}

Position::Position(const Position& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Position)
}

void Position::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:stdmsg.Position)
  SharedDtor();
}

void Position::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Position::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Position::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Position_descriptor_;
}

const Position& Position::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Position* Position::default_instance_ = NULL;

Position* Position::New(::google::protobuf::Arena* arena) const {
  Position* n = new Position;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Position::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Position*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, z_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Position::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Position)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1 [default = 0];
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2 [default = 0];
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // optional double z = 3 [default = 0];
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Position)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Position)
  return false;
#undef DO_
}

void Position::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Position)
  // required double x = 1 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2 [default = 0];
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3 [default = 0];
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Position)
}

::google::protobuf::uint8* Position::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Position)
  // required double x = 1 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2 [default = 0];
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3 [default = 0];
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Position)
  return target;
}

int Position::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_x()) {
    // required double x = 1 [default = 0];
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2 [default = 0];
    total_size += 1 + 8;
  }

  return total_size;
}
int Position::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double x = 1 [default = 0];
    total_size += 1 + 8;

    // required double y = 2 [default = 0];
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional double z = 3 [default = 0];
  if (has_z()) {
    total_size += 1 + 8;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Position::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Position* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Position>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Position::MergeFrom(const Position& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Position::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Position::CopyFrom(const Position& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Position::Swap(Position* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Position::InternalSwap(Position* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Position::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Position_descriptor_;
  metadata.reflection = Position_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Position

// required double x = 1 [default = 0];
bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double Position::x() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.x)
  return x_;
}
 void Position::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.x)
}

// required double y = 2 [default = 0];
bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double Position::y() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.y)
  return y_;
}
 void Position::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.y)
}

// optional double z = 3 [default = 0];
bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double Position::z() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.z)
  return z_;
}
 void Position::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Orentation::kRollFieldNumber;
const int Orentation::kPitchFieldNumber;
const int Orentation::kYawFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Orentation::Orentation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Orentation)
}

void Orentation::InitAsDefaultInstance() {
}

Orentation::Orentation(const Orentation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Orentation)
}

void Orentation::SharedCtor() {
  _cached_size_ = 0;
  roll_ = 0;
  pitch_ = 0;
  yaw_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Orentation::~Orentation() {
  // @@protoc_insertion_point(destructor:stdmsg.Orentation)
  SharedDtor();
}

void Orentation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Orentation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Orentation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Orentation_descriptor_;
}

const Orentation& Orentation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Orentation* Orentation::default_instance_ = NULL;

Orentation* Orentation::New(::google::protobuf::Arena* arena) const {
  Orentation* n = new Orentation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Orentation::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Orentation*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(roll_, yaw_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Orentation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Orentation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double roll = 1 [default = 0];
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &roll_)));
          set_has_roll();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_pitch;
        break;
      }

      // optional double pitch = 2 [default = 0];
      case 2: {
        if (tag == 17) {
         parse_pitch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &pitch_)));
          set_has_pitch();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_yaw;
        break;
      }

      // required double yaw = 3 [default = 0];
      case 3: {
        if (tag == 25) {
         parse_yaw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &yaw_)));
          set_has_yaw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Orentation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Orentation)
  return false;
#undef DO_
}

void Orentation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Orentation)
  // optional double roll = 1 [default = 0];
  if (has_roll()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->roll(), output);
  }

  // optional double pitch = 2 [default = 0];
  if (has_pitch()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->pitch(), output);
  }

  // required double yaw = 3 [default = 0];
  if (has_yaw()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->yaw(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Orentation)
}

::google::protobuf::uint8* Orentation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Orentation)
  // optional double roll = 1 [default = 0];
  if (has_roll()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->roll(), target);
  }

  // optional double pitch = 2 [default = 0];
  if (has_pitch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->pitch(), target);
  }

  // required double yaw = 3 [default = 0];
  if (has_yaw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->yaw(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Orentation)
  return target;
}

int Orentation::ByteSize() const {
  int total_size = 0;

  // required double yaw = 3 [default = 0];
  if (has_yaw()) {
    total_size += 1 + 8;
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional double roll = 1 [default = 0];
    if (has_roll()) {
      total_size += 1 + 8;
    }

    // optional double pitch = 2 [default = 0];
    if (has_pitch()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Orentation::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Orentation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Orentation>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Orentation::MergeFrom(const Orentation& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roll()) {
      set_roll(from.roll());
    }
    if (from.has_pitch()) {
      set_pitch(from.pitch());
    }
    if (from.has_yaw()) {
      set_yaw(from.yaw());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Orentation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Orentation::CopyFrom(const Orentation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Orentation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void Orentation::Swap(Orentation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Orentation::InternalSwap(Orentation* other) {
  std::swap(roll_, other->roll_);
  std::swap(pitch_, other->pitch_);
  std::swap(yaw_, other->yaw_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Orentation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Orentation_descriptor_;
  metadata.reflection = Orentation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Orentation

// optional double roll = 1 [default = 0];
bool Orentation::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Orentation::set_has_roll() {
  _has_bits_[0] |= 0x00000001u;
}
void Orentation::clear_has_roll() {
  _has_bits_[0] &= ~0x00000001u;
}
void Orentation::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
 double Orentation::roll() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.roll)
  return roll_;
}
 void Orentation::set_roll(double value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.roll)
}

// optional double pitch = 2 [default = 0];
bool Orentation::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Orentation::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
void Orentation::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
void Orentation::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
 double Orentation::pitch() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.pitch)
  return pitch_;
}
 void Orentation::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.pitch)
}

// required double yaw = 3 [default = 0];
bool Orentation::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Orentation::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
void Orentation::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
void Orentation::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
 double Orentation::yaw() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.yaw)
  return yaw_;
}
 void Orentation::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.yaw)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pose::kPositionFieldNumber;
const int Pose::kOrentationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pose::Pose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Pose)
}

void Pose::InitAsDefaultInstance() {
  position_ = const_cast< ::stdmsg::Position*>(&::stdmsg::Position::default_instance());
  orentation_ = const_cast< ::stdmsg::Orentation*>(&::stdmsg::Orentation::default_instance());
}

Pose::Pose(const Pose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Pose)
}

void Pose::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  orentation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Pose::~Pose() {
  // @@protoc_insertion_point(destructor:stdmsg.Pose)
  SharedDtor();
}

void Pose::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete orentation_;
  }
}

void Pose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Pose_descriptor_;
}

const Pose& Pose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Pose* Pose::default_instance_ = NULL;

Pose* Pose::New(::google::protobuf::Arena* arena) const {
  Pose* n = new Pose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pose::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_position()) {
      if (position_ != NULL) position_->::stdmsg::Position::Clear();
    }
    if (has_orentation()) {
      if (orentation_ != NULL) orentation_->::stdmsg::Orentation::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Pose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Pose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .stdmsg.Position position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_orentation;
        break;
      }

      // required .stdmsg.Orentation orentation = 2;
      case 2: {
        if (tag == 18) {
         parse_orentation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orentation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Pose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Pose)
  return false;
#undef DO_
}

void Pose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Pose)
  // required .stdmsg.Position position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // required .stdmsg.Orentation orentation = 2;
  if (has_orentation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->orentation_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Pose)
}

::google::protobuf::uint8* Pose::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Pose)
  // required .stdmsg.Position position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->position_, target);
  }

  // required .stdmsg.Orentation orentation = 2;
  if (has_orentation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->orentation_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Pose)
  return target;
}

int Pose::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_position()) {
    // required .stdmsg.Position position = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);
  }

  if (has_orentation()) {
    // required .stdmsg.Orentation orentation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orentation_);
  }

  return total_size;
}
int Pose::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .stdmsg.Position position = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);

    // required .stdmsg.Orentation orentation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orentation_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pose::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Pose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Pose>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Pose::MergeFrom(const Pose& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::stdmsg::Position::MergeFrom(from.position());
    }
    if (from.has_orentation()) {
      mutable_orentation()->::stdmsg::Orentation::MergeFrom(from.orentation());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Pose::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pose::CopyFrom(const Pose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_position()) {
    if (!this->position_->IsInitialized()) return false;
  }
  if (has_orentation()) {
    if (!this->orentation_->IsInitialized()) return false;
  }
  return true;
}

void Pose::Swap(Pose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pose::InternalSwap(Pose* other) {
  std::swap(position_, other->position_);
  std::swap(orentation_, other->orentation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Pose_descriptor_;
  metadata.reflection = Pose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pose

// required .stdmsg.Position position = 1;
bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
void Pose::clear_position() {
  if (position_ != NULL) position_->::stdmsg::Position::Clear();
  clear_has_position();
}
const ::stdmsg::Position& Pose::position() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
::stdmsg::Position* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::stdmsg::Position;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Pose.position)
  return position_;
}
::stdmsg::Position* Pose::release_position() {
  clear_has_position();
  ::stdmsg::Position* temp = position_;
  position_ = NULL;
  return temp;
}
void Pose::set_allocated_position(::stdmsg::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Pose.position)
}

// required .stdmsg.Orentation orentation = 2;
bool Pose::has_orentation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Pose::set_has_orentation() {
  _has_bits_[0] |= 0x00000002u;
}
void Pose::clear_has_orentation() {
  _has_bits_[0] &= ~0x00000002u;
}
void Pose::clear_orentation() {
  if (orentation_ != NULL) orentation_->::stdmsg::Orentation::Clear();
  clear_has_orentation();
}
const ::stdmsg::Orentation& Pose::orentation() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose.orentation)
  return orentation_ != NULL ? *orentation_ : *default_instance_->orentation_;
}
::stdmsg::Orentation* Pose::mutable_orentation() {
  set_has_orentation();
  if (orentation_ == NULL) {
    orentation_ = new ::stdmsg::Orentation;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Pose.orentation)
  return orentation_;
}
::stdmsg::Orentation* Pose::release_orentation() {
  clear_has_orentation();
  ::stdmsg::Orentation* temp = orentation_;
  orentation_ = NULL;
  return temp;
}
void Pose::set_allocated_orentation(::stdmsg::Orentation* orentation) {
  delete orentation_;
  orentation_ = orentation;
  if (orentation) {
    set_has_orentation();
  } else {
    clear_has_orentation();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Pose.orentation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Velocity::kVFieldNumber;
const int Velocity::kWFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Velocity::Velocity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Velocity)
}

void Velocity::InitAsDefaultInstance() {
}

Velocity::Velocity(const Velocity& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Velocity)
}

void Velocity::SharedCtor() {
  _cached_size_ = 0;
  v_ = 0;
  w_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Velocity::~Velocity() {
  // @@protoc_insertion_point(destructor:stdmsg.Velocity)
  SharedDtor();
}

void Velocity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Velocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Velocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Velocity_descriptor_;
}

const Velocity& Velocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Velocity* Velocity::default_instance_ = NULL;

Velocity* Velocity::New(::google::protobuf::Arena* arena) const {
  Velocity* n = new Velocity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Velocity::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Velocity*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(v_, w_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Velocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Velocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double v = 1 [default = 0];
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &v_)));
          set_has_v();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_w;
        break;
      }

      // required double w = 2 [default = 0];
      case 2: {
        if (tag == 17) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Velocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Velocity)
  return false;
#undef DO_
}

void Velocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Velocity)
  // required double v = 1 [default = 0];
  if (has_v()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->v(), output);
  }

  // required double w = 2 [default = 0];
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->w(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Velocity)
}

::google::protobuf::uint8* Velocity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Velocity)
  // required double v = 1 [default = 0];
  if (has_v()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->v(), target);
  }

  // required double w = 2 [default = 0];
  if (has_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->w(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Velocity)
  return target;
}

int Velocity::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_v()) {
    // required double v = 1 [default = 0];
    total_size += 1 + 8;
  }

  if (has_w()) {
    // required double w = 2 [default = 0];
    total_size += 1 + 8;
  }

  return total_size;
}
int Velocity::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double v = 1 [default = 0];
    total_size += 1 + 8;

    // required double w = 2 [default = 0];
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Velocity::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Velocity* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Velocity>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Velocity::MergeFrom(const Velocity& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_v()) {
      set_v(from.v());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Velocity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Velocity::CopyFrom(const Velocity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Velocity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Velocity::Swap(Velocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Velocity::InternalSwap(Velocity* other) {
  std::swap(v_, other->v_);
  std::swap(w_, other->w_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Velocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Velocity_descriptor_;
  metadata.reflection = Velocity_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Velocity

// required double v = 1 [default = 0];
bool Velocity::has_v() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Velocity::set_has_v() {
  _has_bits_[0] |= 0x00000001u;
}
void Velocity::clear_has_v() {
  _has_bits_[0] &= ~0x00000001u;
}
void Velocity::clear_v() {
  v_ = 0;
  clear_has_v();
}
 double Velocity::v() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.v)
  return v_;
}
 void Velocity::set_v(double value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.v)
}

// required double w = 2 [default = 0];
bool Velocity::has_w() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Velocity::set_has_w() {
  _has_bits_[0] |= 0x00000002u;
}
void Velocity::clear_has_w() {
  _has_bits_[0] &= ~0x00000002u;
}
void Velocity::clear_w() {
  w_ = 0;
  clear_has_w();
}
 double Velocity::w() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.w)
  return w_;
}
 void Velocity::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.w)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Laser_Scan_Laser_Config::kAngleMinFieldNumber;
const int Laser_Scan_Laser_Config::kAngleMaxFieldNumber;
const int Laser_Scan_Laser_Config::kAngleIncrementFieldNumber;
const int Laser_Scan_Laser_Config::kRangeMaxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Laser_Scan_Laser_Config::Laser_Scan_Laser_Config()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Laser_Scan.Laser_Config)
}

void Laser_Scan_Laser_Config::InitAsDefaultInstance() {
}

Laser_Scan_Laser_Config::Laser_Scan_Laser_Config(const Laser_Scan_Laser_Config& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Laser_Scan.Laser_Config)
}

void Laser_Scan_Laser_Config::SharedCtor() {
  _cached_size_ = 0;
  angle_min_ = 0;
  angle_max_ = 0;
  angle_increment_ = 0;
  range_max_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Laser_Scan_Laser_Config::~Laser_Scan_Laser_Config() {
  // @@protoc_insertion_point(destructor:stdmsg.Laser_Scan.Laser_Config)
  SharedDtor();
}

void Laser_Scan_Laser_Config::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Laser_Scan_Laser_Config::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Laser_Scan_Laser_Config::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Laser_Scan_Laser_Config_descriptor_;
}

const Laser_Scan_Laser_Config& Laser_Scan_Laser_Config::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Laser_Scan_Laser_Config* Laser_Scan_Laser_Config::default_instance_ = NULL;

Laser_Scan_Laser_Config* Laser_Scan_Laser_Config::New(::google::protobuf::Arena* arena) const {
  Laser_Scan_Laser_Config* n = new Laser_Scan_Laser_Config;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Laser_Scan_Laser_Config::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Laser_Scan_Laser_Config*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(angle_min_, range_max_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Laser_Scan_Laser_Config::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Laser_Scan.Laser_Config)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float angle_min = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_min_)));
          set_has_angle_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_angle_max;
        break;
      }

      // required float angle_max = 2;
      case 2: {
        if (tag == 21) {
         parse_angle_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_max_)));
          set_has_angle_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_angle_increment;
        break;
      }

      // required float angle_increment = 3;
      case 3: {
        if (tag == 29) {
         parse_angle_increment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_increment_)));
          set_has_angle_increment();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_range_max;
        break;
      }

      // required float range_max = 5;
      case 5: {
        if (tag == 45) {
         parse_range_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &range_max_)));
          set_has_range_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Laser_Scan.Laser_Config)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Laser_Scan.Laser_Config)
  return false;
#undef DO_
}

void Laser_Scan_Laser_Config::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Laser_Scan.Laser_Config)
  // required float angle_min = 1;
  if (has_angle_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->angle_min(), output);
  }

  // required float angle_max = 2;
  if (has_angle_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->angle_max(), output);
  }

  // required float angle_increment = 3;
  if (has_angle_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->angle_increment(), output);
  }

  // required float range_max = 5;
  if (has_range_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->range_max(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Laser_Scan.Laser_Config)
}

::google::protobuf::uint8* Laser_Scan_Laser_Config::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Laser_Scan.Laser_Config)
  // required float angle_min = 1;
  if (has_angle_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->angle_min(), target);
  }

  // required float angle_max = 2;
  if (has_angle_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->angle_max(), target);
  }

  // required float angle_increment = 3;
  if (has_angle_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->angle_increment(), target);
  }

  // required float range_max = 5;
  if (has_range_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->range_max(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Laser_Scan.Laser_Config)
  return target;
}

int Laser_Scan_Laser_Config::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_angle_min()) {
    // required float angle_min = 1;
    total_size += 1 + 4;
  }

  if (has_angle_max()) {
    // required float angle_max = 2;
    total_size += 1 + 4;
  }

  if (has_angle_increment()) {
    // required float angle_increment = 3;
    total_size += 1 + 4;
  }

  if (has_range_max()) {
    // required float range_max = 5;
    total_size += 1 + 4;
  }

  return total_size;
}
int Laser_Scan_Laser_Config::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float angle_min = 1;
    total_size += 1 + 4;

    // required float angle_max = 2;
    total_size += 1 + 4;

    // required float angle_increment = 3;
    total_size += 1 + 4;

    // required float range_max = 5;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Laser_Scan_Laser_Config::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Laser_Scan_Laser_Config* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Laser_Scan_Laser_Config>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Laser_Scan_Laser_Config::MergeFrom(const Laser_Scan_Laser_Config& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_angle_min()) {
      set_angle_min(from.angle_min());
    }
    if (from.has_angle_max()) {
      set_angle_max(from.angle_max());
    }
    if (from.has_angle_increment()) {
      set_angle_increment(from.angle_increment());
    }
    if (from.has_range_max()) {
      set_range_max(from.range_max());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Laser_Scan_Laser_Config::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Laser_Scan_Laser_Config::CopyFrom(const Laser_Scan_Laser_Config& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Laser_Scan_Laser_Config::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Laser_Scan_Laser_Config::Swap(Laser_Scan_Laser_Config* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Laser_Scan_Laser_Config::InternalSwap(Laser_Scan_Laser_Config* other) {
  std::swap(angle_min_, other->angle_min_);
  std::swap(angle_max_, other->angle_max_);
  std::swap(angle_increment_, other->angle_increment_);
  std::swap(range_max_, other->range_max_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Laser_Scan_Laser_Config::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Laser_Scan_Laser_Config_descriptor_;
  metadata.reflection = Laser_Scan_Laser_Config_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Laser_Scan::kConfigFieldNumber;
const int Laser_Scan::kRangesFieldNumber;
const int Laser_Scan::kRangesRssiFieldNumber;
const int Laser_Scan::kIntensitiesFieldNumber;
const int Laser_Scan::kPoseFieldNumber;
const int Laser_Scan::kRobotFieldNumber;
const int Laser_Scan::kSteerFieldNumber;
const int Laser_Scan::kSeqFieldNumber;
const int Laser_Scan::kAnnotationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Laser_Scan::Laser_Scan()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Laser_Scan)
}

void Laser_Scan::InitAsDefaultInstance() {
  config_ = const_cast< ::stdmsg::Laser_Scan_Laser_Config*>(&::stdmsg::Laser_Scan_Laser_Config::default_instance());
  pose_ = const_cast< ::stdmsg::Pose*>(&::stdmsg::Pose::default_instance());
  robot_ = const_cast< ::stdmsg::Pose*>(&::stdmsg::Pose::default_instance());
}

Laser_Scan::Laser_Scan(const Laser_Scan& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Laser_Scan)
}

void Laser_Scan::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  config_ = NULL;
  pose_ = NULL;
  robot_ = NULL;
  steer_ = 0;
  seq_ = 0;
  annotation_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Laser_Scan::~Laser_Scan() {
  // @@protoc_insertion_point(destructor:stdmsg.Laser_Scan)
  SharedDtor();
}

void Laser_Scan::SharedDtor() {
  annotation_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete config_;
    delete pose_;
    delete robot_;
  }
}

void Laser_Scan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Laser_Scan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Laser_Scan_descriptor_;
}

const Laser_Scan& Laser_Scan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Laser_Scan* Laser_Scan::default_instance_ = NULL;

Laser_Scan* Laser_Scan::New(::google::protobuf::Arena* arena) const {
  Laser_Scan* n = new Laser_Scan;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Laser_Scan::Clear() {
  if (_has_bits_[0 / 32] & 241u) {
    if (has_config()) {
      if (config_ != NULL) config_->::stdmsg::Laser_Scan_Laser_Config::Clear();
    }
    if (has_pose()) {
      if (pose_ != NULL) pose_->::stdmsg::Pose::Clear();
    }
    if (has_robot()) {
      if (robot_ != NULL) robot_->::stdmsg::Pose::Clear();
    }
    steer_ = 0;
    seq_ = 0;
  }
  if (has_annotation()) {
    annotation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ranges_.Clear();
  ranges_rssi_.Clear();
  intensities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Laser_Scan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Laser_Scan)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .stdmsg.Laser_Scan.Laser_Config config = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_ranges;
        break;
      }

      // repeated float ranges = 2;
      case 2: {
        if (tag == 21) {
         parse_ranges:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_ranges())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_ranges())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_ranges;
        if (input->ExpectTag(29)) goto parse_intensities;
        break;
      }

      // repeated float intensities = 3;
      case 3: {
        if (tag == 29) {
         parse_intensities:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_intensities())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_intensities())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_intensities;
        if (input->ExpectTag(42)) goto parse_pose;
        break;
      }

      // required .stdmsg.Pose pose = 5;
      case 5: {
        if (tag == 42) {
         parse_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_robot;
        break;
      }

      // required .stdmsg.Pose robot = 6;
      case 6: {
        if (tag == 50) {
         parse_robot:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_seq;
        break;
      }

      // optional int32 seq = 7 [default = 0];
      case 7: {
        if (tag == 56) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_annotation;
        break;
      }

      // optional string annotation = 8 [default = ""];
      case 8: {
        if (tag == 66) {
         parse_annotation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_annotation()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->annotation().data(), this->annotation().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.Laser_Scan.annotation");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_steer;
        break;
      }

      // optional double steer = 9;
      case 9: {
        if (tag == 73) {
         parse_steer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steer_)));
          set_has_steer();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_ranges_rssi;
        break;
      }

      // repeated float ranges_rssi = 10;
      case 10: {
        if (tag == 85) {
         parse_ranges_rssi:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 85, input, this->mutable_ranges_rssi())));
        } else if (tag == 82) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_ranges_rssi())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_ranges_rssi;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Laser_Scan)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Laser_Scan)
  return false;
#undef DO_
}

void Laser_Scan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Laser_Scan)
  // required .stdmsg.Laser_Scan.Laser_Config config = 1;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->config_, output);
  }

  // repeated float ranges = 2;
  for (int i = 0; i < this->ranges_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->ranges(i), output);
  }

  // repeated float intensities = 3;
  for (int i = 0; i < this->intensities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->intensities(i), output);
  }

  // required .stdmsg.Pose pose = 5;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->pose_, output);
  }

  // required .stdmsg.Pose robot = 6;
  if (has_robot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->robot_, output);
  }

  // optional int32 seq = 7 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->seq(), output);
  }

  // optional string annotation = 8 [default = ""];
  if (has_annotation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->annotation().data(), this->annotation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Laser_Scan.annotation");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->annotation(), output);
  }

  // optional double steer = 9;
  if (has_steer()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->steer(), output);
  }

  // repeated float ranges_rssi = 10;
  for (int i = 0; i < this->ranges_rssi_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      10, this->ranges_rssi(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Laser_Scan)
}

::google::protobuf::uint8* Laser_Scan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Laser_Scan)
  // required .stdmsg.Laser_Scan.Laser_Config config = 1;
  if (has_config()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->config_, target);
  }

  // repeated float ranges = 2;
  for (int i = 0; i < this->ranges_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(2, this->ranges(i), target);
  }

  // repeated float intensities = 3;
  for (int i = 0; i < this->intensities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(3, this->intensities(i), target);
  }

  // required .stdmsg.Pose pose = 5;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->pose_, target);
  }

  // required .stdmsg.Pose robot = 6;
  if (has_robot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *this->robot_, target);
  }

  // optional int32 seq = 7 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->seq(), target);
  }

  // optional string annotation = 8 [default = ""];
  if (has_annotation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->annotation().data(), this->annotation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Laser_Scan.annotation");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->annotation(), target);
  }

  // optional double steer = 9;
  if (has_steer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->steer(), target);
  }

  // repeated float ranges_rssi = 10;
  for (int i = 0; i < this->ranges_rssi_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(10, this->ranges_rssi(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Laser_Scan)
  return target;
}

int Laser_Scan::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_config()) {
    // required .stdmsg.Laser_Scan.Laser_Config config = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->config_);
  }

  if (has_pose()) {
    // required .stdmsg.Pose pose = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);
  }

  if (has_robot()) {
    // required .stdmsg.Pose robot = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->robot_);
  }

  return total_size;
}
int Laser_Scan::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000031) ^ 0x00000031) == 0) {  // All required fields are present.
    // required .stdmsg.Laser_Scan.Laser_Config config = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->config_);

    // required .stdmsg.Pose pose = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);

    // required .stdmsg.Pose robot = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->robot_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[6 / 32] & 192u) {
    // optional double steer = 9;
    if (has_steer()) {
      total_size += 1 + 8;
    }

    // optional int32 seq = 7 [default = 0];
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

  }
  // optional string annotation = 8 [default = ""];
  if (has_annotation()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->annotation());
  }

  // repeated float ranges = 2;
  {
    int data_size = 0;
    data_size = 4 * this->ranges_size();
    total_size += 1 * this->ranges_size() + data_size;
  }

  // repeated float ranges_rssi = 10;
  {
    int data_size = 0;
    data_size = 4 * this->ranges_rssi_size();
    total_size += 1 * this->ranges_rssi_size() + data_size;
  }

  // repeated float intensities = 3;
  {
    int data_size = 0;
    data_size = 4 * this->intensities_size();
    total_size += 1 * this->intensities_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Laser_Scan::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Laser_Scan* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Laser_Scan>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Laser_Scan::MergeFrom(const Laser_Scan& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  ranges_.MergeFrom(from.ranges_);
  ranges_rssi_.MergeFrom(from.ranges_rssi_);
  intensities_.MergeFrom(from.intensities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_config()) {
      mutable_config()->::stdmsg::Laser_Scan_Laser_Config::MergeFrom(from.config());
    }
    if (from.has_pose()) {
      mutable_pose()->::stdmsg::Pose::MergeFrom(from.pose());
    }
    if (from.has_robot()) {
      mutable_robot()->::stdmsg::Pose::MergeFrom(from.robot());
    }
    if (from.has_steer()) {
      set_steer(from.steer());
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_annotation()) {
      set_has_annotation();
      annotation_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.annotation_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Laser_Scan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Laser_Scan::CopyFrom(const Laser_Scan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Laser_Scan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000031) != 0x00000031) return false;

  if (has_config()) {
    if (!this->config_->IsInitialized()) return false;
  }
  if (has_pose()) {
    if (!this->pose_->IsInitialized()) return false;
  }
  if (has_robot()) {
    if (!this->robot_->IsInitialized()) return false;
  }
  return true;
}

void Laser_Scan::Swap(Laser_Scan* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Laser_Scan::InternalSwap(Laser_Scan* other) {
  std::swap(config_, other->config_);
  ranges_.UnsafeArenaSwap(&other->ranges_);
  ranges_rssi_.UnsafeArenaSwap(&other->ranges_rssi_);
  intensities_.UnsafeArenaSwap(&other->intensities_);
  std::swap(pose_, other->pose_);
  std::swap(robot_, other->robot_);
  std::swap(steer_, other->steer_);
  std::swap(seq_, other->seq_);
  annotation_.Swap(&other->annotation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Laser_Scan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Laser_Scan_descriptor_;
  metadata.reflection = Laser_Scan_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Laser_Scan_Laser_Config

// required float angle_min = 1;
bool Laser_Scan_Laser_Config::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Laser_Scan_Laser_Config::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
void Laser_Scan_Laser_Config::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
void Laser_Scan_Laser_Config::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
 float Laser_Scan_Laser_Config::angle_min() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_min)
  return angle_min_;
}
 void Laser_Scan_Laser_Config::set_angle_min(float value) {
  set_has_angle_min();
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_min)
}

// required float angle_max = 2;
bool Laser_Scan_Laser_Config::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Laser_Scan_Laser_Config::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
void Laser_Scan_Laser_Config::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
void Laser_Scan_Laser_Config::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
 float Laser_Scan_Laser_Config::angle_max() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_max)
  return angle_max_;
}
 void Laser_Scan_Laser_Config::set_angle_max(float value) {
  set_has_angle_max();
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_max)
}

// required float angle_increment = 3;
bool Laser_Scan_Laser_Config::has_angle_increment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Laser_Scan_Laser_Config::set_has_angle_increment() {
  _has_bits_[0] |= 0x00000004u;
}
void Laser_Scan_Laser_Config::clear_has_angle_increment() {
  _has_bits_[0] &= ~0x00000004u;
}
void Laser_Scan_Laser_Config::clear_angle_increment() {
  angle_increment_ = 0;
  clear_has_angle_increment();
}
 float Laser_Scan_Laser_Config::angle_increment() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_increment)
  return angle_increment_;
}
 void Laser_Scan_Laser_Config::set_angle_increment(float value) {
  set_has_angle_increment();
  angle_increment_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_increment)
}

// required float range_max = 5;
bool Laser_Scan_Laser_Config::has_range_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Laser_Scan_Laser_Config::set_has_range_max() {
  _has_bits_[0] |= 0x00000008u;
}
void Laser_Scan_Laser_Config::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000008u;
}
void Laser_Scan_Laser_Config::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
 float Laser_Scan_Laser_Config::range_max() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.range_max)
  return range_max_;
}
 void Laser_Scan_Laser_Config::set_range_max(float value) {
  set_has_range_max();
  range_max_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.range_max)
}

// -------------------------------------------------------------------

// Laser_Scan

// required .stdmsg.Laser_Scan.Laser_Config config = 1;
bool Laser_Scan::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Laser_Scan::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
void Laser_Scan::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void Laser_Scan::clear_config() {
  if (config_ != NULL) config_->::stdmsg::Laser_Scan_Laser_Config::Clear();
  clear_has_config();
}
const ::stdmsg::Laser_Scan_Laser_Config& Laser_Scan::config() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::stdmsg::Laser_Scan_Laser_Config;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.config)
  return config_;
}
::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::release_config() {
  clear_has_config();
  ::stdmsg::Laser_Scan_Laser_Config* temp = config_;
  config_ = NULL;
  return temp;
}
void Laser_Scan::set_allocated_config(::stdmsg::Laser_Scan_Laser_Config* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.config)
}

// repeated float ranges = 2;
int Laser_Scan::ranges_size() const {
  return ranges_.size();
}
void Laser_Scan::clear_ranges() {
  ranges_.Clear();
}
 float Laser_Scan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.ranges)
  return ranges_.Get(index);
}
 void Laser_Scan::set_ranges(int index, float value) {
  ranges_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.ranges)
}
 void Laser_Scan::add_ranges(float value) {
  ranges_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.ranges)
}
 const ::google::protobuf::RepeatedField< float >&
Laser_Scan::ranges() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.ranges)
  return ranges_;
}
 ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.ranges)
  return &ranges_;
}

// repeated float ranges_rssi = 10;
int Laser_Scan::ranges_rssi_size() const {
  return ranges_rssi_.size();
}
void Laser_Scan::clear_ranges_rssi() {
  ranges_rssi_.Clear();
}
 float Laser_Scan::ranges_rssi(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.ranges_rssi)
  return ranges_rssi_.Get(index);
}
 void Laser_Scan::set_ranges_rssi(int index, float value) {
  ranges_rssi_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.ranges_rssi)
}
 void Laser_Scan::add_ranges_rssi(float value) {
  ranges_rssi_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.ranges_rssi)
}
 const ::google::protobuf::RepeatedField< float >&
Laser_Scan::ranges_rssi() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.ranges_rssi)
  return ranges_rssi_;
}
 ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_ranges_rssi() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.ranges_rssi)
  return &ranges_rssi_;
}

// repeated float intensities = 3;
int Laser_Scan::intensities_size() const {
  return intensities_.size();
}
void Laser_Scan::clear_intensities() {
  intensities_.Clear();
}
 float Laser_Scan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.intensities)
  return intensities_.Get(index);
}
 void Laser_Scan::set_intensities(int index, float value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.intensities)
}
 void Laser_Scan::add_intensities(float value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.intensities)
}
 const ::google::protobuf::RepeatedField< float >&
Laser_Scan::intensities() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.intensities)
  return intensities_;
}
 ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.intensities)
  return &intensities_;
}

// required .stdmsg.Pose pose = 5;
bool Laser_Scan::has_pose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Laser_Scan::set_has_pose() {
  _has_bits_[0] |= 0x00000010u;
}
void Laser_Scan::clear_has_pose() {
  _has_bits_[0] &= ~0x00000010u;
}
void Laser_Scan::clear_pose() {
  if (pose_ != NULL) pose_->::stdmsg::Pose::Clear();
  clear_has_pose();
}
const ::stdmsg::Pose& Laser_Scan::pose() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
::stdmsg::Pose* Laser_Scan::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::stdmsg::Pose;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.pose)
  return pose_;
}
::stdmsg::Pose* Laser_Scan::release_pose() {
  clear_has_pose();
  ::stdmsg::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
void Laser_Scan::set_allocated_pose(::stdmsg::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.pose)
}

// required .stdmsg.Pose robot = 6;
bool Laser_Scan::has_robot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Laser_Scan::set_has_robot() {
  _has_bits_[0] |= 0x00000020u;
}
void Laser_Scan::clear_has_robot() {
  _has_bits_[0] &= ~0x00000020u;
}
void Laser_Scan::clear_robot() {
  if (robot_ != NULL) robot_->::stdmsg::Pose::Clear();
  clear_has_robot();
}
const ::stdmsg::Pose& Laser_Scan::robot() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.robot)
  return robot_ != NULL ? *robot_ : *default_instance_->robot_;
}
::stdmsg::Pose* Laser_Scan::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    robot_ = new ::stdmsg::Pose;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.robot)
  return robot_;
}
::stdmsg::Pose* Laser_Scan::release_robot() {
  clear_has_robot();
  ::stdmsg::Pose* temp = robot_;
  robot_ = NULL;
  return temp;
}
void Laser_Scan::set_allocated_robot(::stdmsg::Pose* robot) {
  delete robot_;
  robot_ = robot;
  if (robot) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.robot)
}

// optional double steer = 9;
bool Laser_Scan::has_steer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Laser_Scan::set_has_steer() {
  _has_bits_[0] |= 0x00000040u;
}
void Laser_Scan::clear_has_steer() {
  _has_bits_[0] &= ~0x00000040u;
}
void Laser_Scan::clear_steer() {
  steer_ = 0;
  clear_has_steer();
}
 double Laser_Scan::steer() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.steer)
  return steer_;
}
 void Laser_Scan::set_steer(double value) {
  set_has_steer();
  steer_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.steer)
}

// optional int32 seq = 7 [default = 0];
bool Laser_Scan::has_seq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Laser_Scan::set_has_seq() {
  _has_bits_[0] |= 0x00000080u;
}
void Laser_Scan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000080u;
}
void Laser_Scan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 Laser_Scan::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.seq)
  return seq_;
}
 void Laser_Scan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.seq)
}

// optional string annotation = 8 [default = ""];
bool Laser_Scan::has_annotation() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Laser_Scan::set_has_annotation() {
  _has_bits_[0] |= 0x00000100u;
}
void Laser_Scan::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000100u;
}
void Laser_Scan::clear_annotation() {
  annotation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_annotation();
}
 const ::std::string& Laser_Scan::annotation() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.annotation)
  return annotation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Laser_Scan::set_annotation(const ::std::string& value) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.annotation)
}
 void Laser_Scan::set_annotation(const char* value) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Laser_Scan.annotation)
}
 void Laser_Scan::set_annotation(const char* value, size_t size) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Laser_Scan.annotation)
}
 ::std::string* Laser_Scan::mutable_annotation() {
  set_has_annotation();
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.annotation)
  return annotation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Laser_Scan::release_annotation() {
  clear_has_annotation();
  return annotation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Laser_Scan::set_allocated_annotation(::std::string* annotation) {
  if (annotation != NULL) {
    set_has_annotation();
  } else {
    clear_has_annotation();
  }
  annotation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), annotation);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.annotation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Global_Plan::kPathFieldNumber;
const int Global_Plan::kSeqFieldNumber;
const int Global_Plan::kGoalReachedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Global_Plan::Global_Plan()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Global_Plan)
}

void Global_Plan::InitAsDefaultInstance() {
}

Global_Plan::Global_Plan(const Global_Plan& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Global_Plan)
}

void Global_Plan::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  goal_reached_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Global_Plan::~Global_Plan() {
  // @@protoc_insertion_point(destructor:stdmsg.Global_Plan)
  SharedDtor();
}

void Global_Plan::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Global_Plan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Global_Plan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Global_Plan_descriptor_;
}

const Global_Plan& Global_Plan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Global_Plan* Global_Plan::default_instance_ = NULL;

Global_Plan* Global_Plan::New(::google::protobuf::Arena* arena) const {
  Global_Plan* n = new Global_Plan;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Global_Plan::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Global_Plan*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(seq_, goal_reached_);

#undef ZR_HELPER_
#undef ZR_

  path_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Global_Plan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Global_Plan)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .stdmsg.Pose path = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_path;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // optional int32 seq = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_goal_reached;
        break;
      }

      // optional int32 goal_reached = 3 [default = 0];
      case 3: {
        if (tag == 24) {
         parse_goal_reached:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &goal_reached_)));
          set_has_goal_reached();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Global_Plan)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Global_Plan)
  return false;
#undef DO_
}

void Global_Plan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Global_Plan)
  // repeated .stdmsg.Pose path = 1;
  for (unsigned int i = 0, n = this->path_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->path(i), output);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  // optional int32 goal_reached = 3 [default = 0];
  if (has_goal_reached()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->goal_reached(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Global_Plan)
}

::google::protobuf::uint8* Global_Plan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Global_Plan)
  // repeated .stdmsg.Pose path = 1;
  for (unsigned int i = 0, n = this->path_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->path(i), target);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  // optional int32 goal_reached = 3 [default = 0];
  if (has_goal_reached()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->goal_reached(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Global_Plan)
  return target;
}

int Global_Plan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & 6u) {
    // optional int32 seq = 2 [default = 0];
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

    // optional int32 goal_reached = 3 [default = 0];
    if (has_goal_reached()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->goal_reached());
    }

  }
  // repeated .stdmsg.Pose path = 1;
  total_size += 1 * this->path_size();
  for (int i = 0; i < this->path_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->path(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Global_Plan::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Global_Plan* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Global_Plan>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Global_Plan::MergeFrom(const Global_Plan& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  path_.MergeFrom(from.path_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_goal_reached()) {
      set_goal_reached(from.goal_reached());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Global_Plan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Global_Plan::CopyFrom(const Global_Plan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Global_Plan::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->path())) return false;
  return true;
}

void Global_Plan::Swap(Global_Plan* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Global_Plan::InternalSwap(Global_Plan* other) {
  path_.UnsafeArenaSwap(&other->path_);
  std::swap(seq_, other->seq_);
  std::swap(goal_reached_, other->goal_reached_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Global_Plan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Global_Plan_descriptor_;
  metadata.reflection = Global_Plan_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Global_Plan

// repeated .stdmsg.Pose path = 1;
int Global_Plan::path_size() const {
  return path_.size();
}
void Global_Plan::clear_path() {
  path_.Clear();
}
const ::stdmsg::Pose& Global_Plan::path(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.path)
  return path_.Get(index);
}
::stdmsg::Pose* Global_Plan::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Global_Plan.path)
  return path_.Mutable(index);
}
::stdmsg::Pose* Global_Plan::add_path() {
  // @@protoc_insertion_point(field_add:stdmsg.Global_Plan.path)
  return path_.Add();
}
::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >*
Global_Plan::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Global_Plan.path)
  return &path_;
}
const ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >&
Global_Plan::path() const {
  // @@protoc_insertion_point(field_list:stdmsg.Global_Plan.path)
  return path_;
}

// optional int32 seq = 2 [default = 0];
bool Global_Plan::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Global_Plan::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
void Global_Plan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
void Global_Plan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 Global_Plan::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.seq)
  return seq_;
}
 void Global_Plan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.seq)
}

// optional int32 goal_reached = 3 [default = 0];
bool Global_Plan::has_goal_reached() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Global_Plan::set_has_goal_reached() {
  _has_bits_[0] |= 0x00000004u;
}
void Global_Plan::clear_has_goal_reached() {
  _has_bits_[0] &= ~0x00000004u;
}
void Global_Plan::clear_goal_reached() {
  goal_reached_ = 0;
  clear_has_goal_reached();
}
 ::google::protobuf::int32 Global_Plan::goal_reached() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.goal_reached)
  return goal_reached_;
}
 void Global_Plan::set_goal_reached(::google::protobuf::int32 value) {
  set_has_goal_reached();
  goal_reached_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.goal_reached)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Data::kDataFieldNumber;
const int Data::kSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Data::Data()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Data)
}

void Data::InitAsDefaultInstance() {
}

Data::Data(const Data& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Data)
}

void Data::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Data::~Data() {
  // @@protoc_insertion_point(destructor:stdmsg.Data)
  SharedDtor();
}

void Data::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Data::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Data_descriptor_;
}

const Data& Data::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Data* Data::default_instance_ = NULL;

Data* Data::New(::google::protobuf::Arena* arena) const {
  Data* n = new Data;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Data::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    seq_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Data)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data = 1 [default = ""];
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // optional int32 seq = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Data)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Data)
  return false;
#undef DO_
}

void Data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Data)
  // optional bytes data = 1 [default = ""];
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Data)
}

::google::protobuf::uint8* Data::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Data)
  // optional bytes data = 1 [default = ""];
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->data(), target);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Data)
  return target;
}

int Data::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes data = 1 [default = ""];
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional int32 seq = 2 [default = 0];
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Data::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Data* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Data>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Data::MergeFrom(const Data& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Data::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Data::CopyFrom(const Data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Data::IsInitialized() const {

  return true;
}

void Data::Swap(Data* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Data::InternalSwap(Data* other) {
  data_.Swap(&other->data_);
  std::swap(seq_, other->seq_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Data::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Data_descriptor_;
  metadata.reflection = Data_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Data

// optional bytes data = 1 [default = ""];
bool Data::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Data::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
void Data::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
void Data::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& Data::data() const {
  // @@protoc_insertion_point(field_get:stdmsg.Data.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Data::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Data.data)
}
 void Data::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Data.data)
}
 void Data::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Data.data)
}
 ::std::string* Data::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:stdmsg.Data.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Data::release_data() {
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Data::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Data.data)
}

// optional int32 seq = 2 [default = 0];
bool Data::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Data::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
void Data::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
void Data::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 Data::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Data.seq)
  return seq_;
}
 void Data::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Data.seq)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int String::kStrFieldNumber;
const int String::kSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

String::String()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.String)
}

void String::InitAsDefaultInstance() {
}

String::String(const String& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.String)
}

void String::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  str_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

String::~String() {
  // @@protoc_insertion_point(destructor:stdmsg.String)
  SharedDtor();
}

void String::SharedDtor() {
  str_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void String::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* String::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return String_descriptor_;
}

const String& String::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

String* String::default_instance_ = NULL;

String* String::New(::google::protobuf::Arena* arena) const {
  String* n = new String;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void String::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_str()) {
      str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    seq_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool String::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.String)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes str = 1 [default = ""];
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_str()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // optional int32 seq = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.String)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.String)
  return false;
#undef DO_
}

void String::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.String)
  // optional bytes str = 1 [default = ""];
  if (has_str()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->str(), output);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.String)
}

::google::protobuf::uint8* String::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.String)
  // optional bytes str = 1 [default = ""];
  if (has_str()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->str(), target);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.String)
  return target;
}

int String::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes str = 1 [default = ""];
    if (has_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->str());
    }

    // optional int32 seq = 2 [default = 0];
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seq());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void String::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const String* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const String>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void String::MergeFrom(const String& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_str()) {
      set_has_str();
      str_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.str_);
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void String::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void String::CopyFrom(const String& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool String::IsInitialized() const {

  return true;
}

void String::Swap(String* other) {
  if (other == this) return;
  InternalSwap(other);
}
void String::InternalSwap(String* other) {
  str_.Swap(&other->str_);
  std::swap(seq_, other->seq_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata String::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = String_descriptor_;
  metadata.reflection = String_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// String

// optional bytes str = 1 [default = ""];
bool String::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void String::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
void String::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
void String::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_str();
}
 const ::std::string& String::str() const {
  // @@protoc_insertion_point(field_get:stdmsg.String.str)
  return str_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void String::set_str(const ::std::string& value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.String.str)
}
 void String::set_str(const char* value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.String.str)
}
 void String::set_str(const void* value, size_t size) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.String.str)
}
 ::std::string* String::mutable_str() {
  set_has_str();
  // @@protoc_insertion_point(field_mutable:stdmsg.String.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* String::release_str() {
  clear_has_str();
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void String::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    set_has_str();
  } else {
    clear_has_str();
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.String.str)
}

// optional int32 seq = 2 [default = 0];
bool String::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void String::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
void String::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
void String::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 String::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.String.seq)
  return seq_;
}
 void String::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.String.seq)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaserList::kScansFieldNumber;
const int LaserList::kSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaserList::LaserList()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.LaserList)
}

void LaserList::InitAsDefaultInstance() {
}

LaserList::LaserList(const LaserList& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.LaserList)
}

void LaserList::SharedCtor() {
  _cached_size_ = 0;
  seq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaserList::~LaserList() {
  // @@protoc_insertion_point(destructor:stdmsg.LaserList)
  SharedDtor();
}

void LaserList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LaserList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaserList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaserList_descriptor_;
}

const LaserList& LaserList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

LaserList* LaserList::default_instance_ = NULL;

LaserList* LaserList::New(::google::protobuf::Arena* arena) const {
  LaserList* n = new LaserList;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaserList::Clear() {
  seq_ = 0;
  scans_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LaserList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.LaserList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .stdmsg.Laser_Scan scans = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_scans:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_scans()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_scans;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // optional int32 seq = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.LaserList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.LaserList)
  return false;
#undef DO_
}

void LaserList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.LaserList)
  // repeated .stdmsg.Laser_Scan scans = 1;
  for (unsigned int i = 0, n = this->scans_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->scans(i), output);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->seq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.LaserList)
}

::google::protobuf::uint8* LaserList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.LaserList)
  // repeated .stdmsg.Laser_Scan scans = 1;
  for (unsigned int i = 0, n = this->scans_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->scans(i), target);
  }

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->seq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.LaserList)
  return target;
}

int LaserList::ByteSize() const {
  int total_size = 0;

  // optional int32 seq = 2 [default = 0];
  if (has_seq()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->seq());
  }

  // repeated .stdmsg.Laser_Scan scans = 1;
  total_size += 1 * this->scans_size();
  for (int i = 0; i < this->scans_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->scans(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaserList::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const LaserList* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LaserList>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LaserList::MergeFrom(const LaserList& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  scans_.MergeFrom(from.scans_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LaserList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserList::CopyFrom(const LaserList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserList::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->scans())) return false;
  return true;
}

void LaserList::Swap(LaserList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaserList::InternalSwap(LaserList* other) {
  scans_.UnsafeArenaSwap(&other->scans_);
  std::swap(seq_, other->seq_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaserList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaserList_descriptor_;
  metadata.reflection = LaserList_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LaserList

// repeated .stdmsg.Laser_Scan scans = 1;
int LaserList::scans_size() const {
  return scans_.size();
}
void LaserList::clear_scans() {
  scans_.Clear();
}
const ::stdmsg::Laser_Scan& LaserList::scans(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.LaserList.scans)
  return scans_.Get(index);
}
::stdmsg::Laser_Scan* LaserList::mutable_scans(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.LaserList.scans)
  return scans_.Mutable(index);
}
::stdmsg::Laser_Scan* LaserList::add_scans() {
  // @@protoc_insertion_point(field_add:stdmsg.LaserList.scans)
  return scans_.Add();
}
::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >*
LaserList::mutable_scans() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.LaserList.scans)
  return &scans_;
}
const ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >&
LaserList::scans() const {
  // @@protoc_insertion_point(field_list:stdmsg.LaserList.scans)
  return scans_;
}

// optional int32 seq = 2 [default = 0];
bool LaserList::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LaserList::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
void LaserList::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
void LaserList::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
 ::google::protobuf::int32 LaserList::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.LaserList.seq)
  return seq_;
}
 void LaserList::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.LaserList.seq)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Block::kNameFieldNumber;
const int Block::kInputFieldNumber;
const int Block::kInputTypeFieldNumber;
const int Block::kOutputFieldNumber;
const int Block::kOutputTypeFieldNumber;
const int Block::kDllFieldNumber;
const int Block::kObjectFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Block::Block()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Block)
}

void Block::InitAsDefaultInstance() {
}

Block::Block(const Block& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Block)
}

void Block::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dll_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  object_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Block::~Block() {
  // @@protoc_insertion_point(destructor:stdmsg.Block)
  SharedDtor();
}

void Block::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dll_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  object_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Block::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Block::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Block_descriptor_;
}

const Block& Block::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Block* Block::default_instance_ = NULL;

Block* Block::New(::google::protobuf::Arena* arena) const {
  Block* n = new Block;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Block::Clear() {
  if (_has_bits_[0 / 32] & 97u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_dll()) {
      dll_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_object()) {
      object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  input_.Clear();
  input_type_.Clear();
  output_.Clear();
  output_type_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Block::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Block)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.Block.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_input;
        break;
      }

      // repeated string input = 2;
      case 2: {
        if (tag == 18) {
         parse_input:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_input()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->input(this->input_size() - 1).data(),
            this->input(this->input_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.Block.input");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_input;
        if (input->ExpectTag(26)) goto parse_input_type;
        break;
      }

      // repeated string input_type = 3;
      case 3: {
        if (tag == 26) {
         parse_input_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_input_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->input_type(this->input_type_size() - 1).data(),
            this->input_type(this->input_type_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.Block.input_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_input_type;
        if (input->ExpectTag(34)) goto parse_output;
        break;
      }

      // repeated string output = 4;
      case 4: {
        if (tag == 34) {
         parse_output:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_output()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->output(this->output_size() - 1).data(),
            this->output(this->output_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.Block.output");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_output;
        if (input->ExpectTag(42)) goto parse_output_type;
        break;
      }

      // repeated string output_type = 5;
      case 5: {
        if (tag == 42) {
         parse_output_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_output_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->output_type(this->output_type_size() - 1).data(),
            this->output_type(this->output_type_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.Block.output_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_output_type;
        if (input->ExpectTag(50)) goto parse_dll;
        break;
      }

      // required string dll = 6;
      case 6: {
        if (tag == 50) {
         parse_dll:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dll()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->dll().data(), this->dll().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.Block.dll");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_object;
        break;
      }

      // required string object = 7;
      case 7: {
        if (tag == 58) {
         parse_object:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_object()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->object().data(), this->object().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "stdmsg.Block.object");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Block)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Block)
  return false;
#undef DO_
}

void Block::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Block)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // repeated string input = 2;
  for (int i = 0; i < this->input_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->input(i).data(), this->input(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.input");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->input(i), output);
  }

  // repeated string input_type = 3;
  for (int i = 0; i < this->input_type_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->input_type(i).data(), this->input_type(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.input_type");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->input_type(i), output);
  }

  // repeated string output = 4;
  for (int i = 0; i < this->output_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->output(i).data(), this->output(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.output");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->output(i), output);
  }

  // repeated string output_type = 5;
  for (int i = 0; i < this->output_type_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->output_type(i).data(), this->output_type(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.output_type");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->output_type(i), output);
  }

  // required string dll = 6;
  if (has_dll()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->dll().data(), this->dll().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.dll");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->dll(), output);
  }

  // required string object = 7;
  if (has_object()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->object().data(), this->object().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.object");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->object(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Block)
}

::google::protobuf::uint8* Block::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Block)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // repeated string input = 2;
  for (int i = 0; i < this->input_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->input(i).data(), this->input(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.input");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->input(i), target);
  }

  // repeated string input_type = 3;
  for (int i = 0; i < this->input_type_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->input_type(i).data(), this->input_type(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.input_type");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->input_type(i), target);
  }

  // repeated string output = 4;
  for (int i = 0; i < this->output_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->output(i).data(), this->output(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.output");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(4, this->output(i), target);
  }

  // repeated string output_type = 5;
  for (int i = 0; i < this->output_type_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->output_type(i).data(), this->output_type(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.output_type");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(5, this->output_type(i), target);
  }

  // required string dll = 6;
  if (has_dll()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->dll().data(), this->dll().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.dll");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->dll(), target);
  }

  // required string object = 7;
  if (has_object()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->object().data(), this->object().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "stdmsg.Block.object");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->object(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Block)
  return target;
}

int Block::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_dll()) {
    // required string dll = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->dll());
  }

  if (has_object()) {
    // required string object = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->object());
  }

  return total_size;
}
int Block::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000061) ^ 0x00000061) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required string dll = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->dll());

    // required string object = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->object());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated string input = 2;
  total_size += 1 * this->input_size();
  for (int i = 0; i < this->input_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->input(i));
  }

  // repeated string input_type = 3;
  total_size += 1 * this->input_type_size();
  for (int i = 0; i < this->input_type_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->input_type(i));
  }

  // repeated string output = 4;
  total_size += 1 * this->output_size();
  for (int i = 0; i < this->output_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->output(i));
  }

  // repeated string output_type = 5;
  total_size += 1 * this->output_type_size();
  for (int i = 0; i < this->output_type_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->output_type(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Block::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Block* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Block>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Block::MergeFrom(const Block& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  input_.MergeFrom(from.input_);
  input_type_.MergeFrom(from.input_type_);
  output_.MergeFrom(from.output_);
  output_type_.MergeFrom(from.output_type_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_dll()) {
      set_has_dll();
      dll_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dll_);
    }
    if (from.has_object()) {
      set_has_object();
      object_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.object_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Block::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Block::CopyFrom(const Block& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Block::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000061) != 0x00000061) return false;

  return true;
}

void Block::Swap(Block* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Block::InternalSwap(Block* other) {
  name_.Swap(&other->name_);
  input_.UnsafeArenaSwap(&other->input_);
  input_type_.UnsafeArenaSwap(&other->input_type_);
  output_.UnsafeArenaSwap(&other->output_);
  output_type_.UnsafeArenaSwap(&other->output_type_);
  dll_.Swap(&other->dll_);
  object_.Swap(&other->object_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Block::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Block_descriptor_;
  metadata.reflection = Block_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Block

// required string name = 1;
bool Block::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Block::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Block::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Block::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Block::name() const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Block::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Block.name)
}
 void Block::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.name)
}
 void Block::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.name)
}
 ::std::string* Block::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Block::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Block::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Block.name)
}

// repeated string input = 2;
int Block::input_size() const {
  return input_.size();
}
void Block::clear_input() {
  input_.Clear();
}
 const ::std::string& Block::input(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.input)
  return input_.Get(index);
}
 ::std::string* Block::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.input)
  return input_.Mutable(index);
}
 void Block::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:stdmsg.Block.input)
  input_.Mutable(index)->assign(value);
}
 void Block::set_input(int index, const char* value) {
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.input)
}
 void Block::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.input)
}
 ::std::string* Block::add_input() {
  return input_.Add();
}
 void Block::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stdmsg.Block.input)
}
 void Block::add_input(const char* value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stdmsg.Block.input)
}
 void Block::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stdmsg.Block.input)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::input() const {
  // @@protoc_insertion_point(field_list:stdmsg.Block.input)
  return input_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Block.input)
  return &input_;
}

// repeated string input_type = 3;
int Block::input_type_size() const {
  return input_type_.size();
}
void Block::clear_input_type() {
  input_type_.Clear();
}
 const ::std::string& Block::input_type(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.input_type)
  return input_type_.Get(index);
}
 ::std::string* Block::mutable_input_type(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.input_type)
  return input_type_.Mutable(index);
}
 void Block::set_input_type(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:stdmsg.Block.input_type)
  input_type_.Mutable(index)->assign(value);
}
 void Block::set_input_type(int index, const char* value) {
  input_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.input_type)
}
 void Block::set_input_type(int index, const char* value, size_t size) {
  input_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.input_type)
}
 ::std::string* Block::add_input_type() {
  return input_type_.Add();
}
 void Block::add_input_type(const ::std::string& value) {
  input_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stdmsg.Block.input_type)
}
 void Block::add_input_type(const char* value) {
  input_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stdmsg.Block.input_type)
}
 void Block::add_input_type(const char* value, size_t size) {
  input_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stdmsg.Block.input_type)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::input_type() const {
  // @@protoc_insertion_point(field_list:stdmsg.Block.input_type)
  return input_type_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_input_type() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Block.input_type)
  return &input_type_;
}

// repeated string output = 4;
int Block::output_size() const {
  return output_.size();
}
void Block::clear_output() {
  output_.Clear();
}
 const ::std::string& Block::output(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.output)
  return output_.Get(index);
}
 ::std::string* Block::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.output)
  return output_.Mutable(index);
}
 void Block::set_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:stdmsg.Block.output)
  output_.Mutable(index)->assign(value);
}
 void Block::set_output(int index, const char* value) {
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.output)
}
 void Block::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.output)
}
 ::std::string* Block::add_output() {
  return output_.Add();
}
 void Block::add_output(const ::std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stdmsg.Block.output)
}
 void Block::add_output(const char* value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stdmsg.Block.output)
}
 void Block::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stdmsg.Block.output)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::output() const {
  // @@protoc_insertion_point(field_list:stdmsg.Block.output)
  return output_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Block.output)
  return &output_;
}

// repeated string output_type = 5;
int Block::output_type_size() const {
  return output_type_.size();
}
void Block::clear_output_type() {
  output_type_.Clear();
}
 const ::std::string& Block::output_type(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.output_type)
  return output_type_.Get(index);
}
 ::std::string* Block::mutable_output_type(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.output_type)
  return output_type_.Mutable(index);
}
 void Block::set_output_type(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:stdmsg.Block.output_type)
  output_type_.Mutable(index)->assign(value);
}
 void Block::set_output_type(int index, const char* value) {
  output_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.output_type)
}
 void Block::set_output_type(int index, const char* value, size_t size) {
  output_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.output_type)
}
 ::std::string* Block::add_output_type() {
  return output_type_.Add();
}
 void Block::add_output_type(const ::std::string& value) {
  output_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stdmsg.Block.output_type)
}
 void Block::add_output_type(const char* value) {
  output_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stdmsg.Block.output_type)
}
 void Block::add_output_type(const char* value, size_t size) {
  output_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stdmsg.Block.output_type)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::output_type() const {
  // @@protoc_insertion_point(field_list:stdmsg.Block.output_type)
  return output_type_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_output_type() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Block.output_type)
  return &output_type_;
}

// required string dll = 6;
bool Block::has_dll() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Block::set_has_dll() {
  _has_bits_[0] |= 0x00000020u;
}
void Block::clear_has_dll() {
  _has_bits_[0] &= ~0x00000020u;
}
void Block::clear_dll() {
  dll_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dll();
}
 const ::std::string& Block::dll() const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.dll)
  return dll_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Block::set_dll(const ::std::string& value) {
  set_has_dll();
  dll_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Block.dll)
}
 void Block::set_dll(const char* value) {
  set_has_dll();
  dll_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.dll)
}
 void Block::set_dll(const char* value, size_t size) {
  set_has_dll();
  dll_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.dll)
}
 ::std::string* Block::mutable_dll() {
  set_has_dll();
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.dll)
  return dll_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Block::release_dll() {
  clear_has_dll();
  return dll_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Block::set_allocated_dll(::std::string* dll) {
  if (dll != NULL) {
    set_has_dll();
  } else {
    clear_has_dll();
  }
  dll_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dll);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Block.dll)
}

// required string object = 7;
bool Block::has_object() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Block::set_has_object() {
  _has_bits_[0] |= 0x00000040u;
}
void Block::clear_has_object() {
  _has_bits_[0] &= ~0x00000040u;
}
void Block::clear_object() {
  object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object();
}
 const ::std::string& Block::object() const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.object)
  return object_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Block::set_object(const ::std::string& value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Block.object)
}
 void Block::set_object(const char* value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.object)
}
 void Block::set_object(const char* value, size_t size) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.object)
}
 ::std::string* Block::mutable_object() {
  set_has_object();
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.object)
  return object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Block::release_object() {
  clear_has_object();
  return object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Block::set_allocated_object(::std::string* object) {
  if (object != NULL) {
    set_has_object();
  } else {
    clear_has_object();
  }
  object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Block.object)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Net::kBlockFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Net::Net()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stdmsg.Net)
}

void Net::InitAsDefaultInstance() {
}

Net::Net(const Net& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stdmsg.Net)
}

void Net::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Net::~Net() {
  // @@protoc_insertion_point(destructor:stdmsg.Net)
  SharedDtor();
}

void Net::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Net::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Net::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Net_descriptor_;
}

const Net& Net::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_stdmsg_2eproto();
  return *default_instance_;
}

Net* Net::default_instance_ = NULL;

Net* Net::New(::google::protobuf::Arena* arena) const {
  Net* n = new Net;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Net::Clear() {
  block_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Net::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stdmsg.Net)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .stdmsg.Block block = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_block:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_block()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_block;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stdmsg.Net)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stdmsg.Net)
  return false;
#undef DO_
}

void Net::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stdmsg.Net)
  // repeated .stdmsg.Block block = 1;
  for (unsigned int i = 0, n = this->block_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->block(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stdmsg.Net)
}

::google::protobuf::uint8* Net::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stdmsg.Net)
  // repeated .stdmsg.Block block = 1;
  for (unsigned int i = 0, n = this->block_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->block(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stdmsg.Net)
  return target;
}

int Net::ByteSize() const {
  int total_size = 0;

  // repeated .stdmsg.Block block = 1;
  total_size += 1 * this->block_size();
  for (int i = 0; i < this->block_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->block(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Net::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Net* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Net>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Net::MergeFrom(const Net& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  block_.MergeFrom(from.block_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Net::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Net::CopyFrom(const Net& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Net::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->block())) return false;
  return true;
}

void Net::Swap(Net* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Net::InternalSwap(Net* other) {
  block_.UnsafeArenaSwap(&other->block_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Net::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Net_descriptor_;
  metadata.reflection = Net_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Net

// repeated .stdmsg.Block block = 1;
int Net::block_size() const {
  return block_.size();
}
void Net::clear_block() {
  block_.Clear();
}
const ::stdmsg::Block& Net::block(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Net.block)
  return block_.Get(index);
}
::stdmsg::Block* Net::mutable_block(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Net.block)
  return block_.Mutable(index);
}
::stdmsg::Block* Net::add_block() {
  // @@protoc_insertion_point(field_add:stdmsg.Net.block)
  return block_.Add();
}
::google::protobuf::RepeatedPtrField< ::stdmsg::Block >*
Net::mutable_block() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Net.block)
  return &block_;
}
const ::google::protobuf::RepeatedPtrField< ::stdmsg::Block >&
Net::block() const {
  // @@protoc_insertion_point(field_list:stdmsg.Net.block)
  return block_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace stdmsg

// @@protoc_insertion_point(global_scope)
