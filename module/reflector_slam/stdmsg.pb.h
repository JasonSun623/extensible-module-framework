// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stdmsg.proto

#ifndef PROTOBUF_stdmsg_2eproto__INCLUDED
#define PROTOBUF_stdmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace stdmsg {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_stdmsg_2eproto();
void protobuf_AssignDesc_stdmsg_2eproto();
void protobuf_ShutdownFile_stdmsg_2eproto();

class Block;
class Data;
class Global_Plan;
class LaserList;
class Laser_Scan;
class Laser_Scan_Laser_Config;
class Net;
class Orentation;
class Pose;
class Position;
class String;
class Velocity;

// ===================================================================

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1 [default = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2 [default = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3 [default = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Orentation : public ::google::protobuf::Message {
 public:
  Orentation();
  virtual ~Orentation();

  Orentation(const Orentation& from);

  inline Orentation& operator=(const Orentation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Orentation& default_instance();

  void Swap(Orentation* other);

  // implements Message ----------------------------------------------

  inline Orentation* New() const { return New(NULL); }

  Orentation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Orentation& from);
  void MergeFrom(const Orentation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Orentation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double roll = 1 [default = 0];
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 1;
  double roll() const;
  void set_roll(double value);

  // optional double pitch = 2 [default = 0];
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  double pitch() const;
  void set_pitch(double value);

  // required double yaw = 3 [default = 0];
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  double yaw() const;
  void set_yaw(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Orentation)
 private:
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double roll_;
  double pitch_;
  double yaw_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Orentation* default_instance_;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  inline Pose* New() const { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .stdmsg.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::stdmsg::Position& position() const;
  ::stdmsg::Position* mutable_position();
  ::stdmsg::Position* release_position();
  void set_allocated_position(::stdmsg::Position* position);

  // required .stdmsg.Orentation orentation = 2;
  bool has_orentation() const;
  void clear_orentation();
  static const int kOrentationFieldNumber = 2;
  const ::stdmsg::Orentation& orentation() const;
  ::stdmsg::Orentation* mutable_orentation();
  ::stdmsg::Orentation* release_orentation();
  void set_allocated_orentation(::stdmsg::Orentation* orentation);

  // @@protoc_insertion_point(class_scope:stdmsg.Pose)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orentation();
  inline void clear_has_orentation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::stdmsg::Position* position_;
  ::stdmsg::Orentation* orentation_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Pose* default_instance_;
};
// -------------------------------------------------------------------

class Velocity : public ::google::protobuf::Message {
 public:
  Velocity();
  virtual ~Velocity();

  Velocity(const Velocity& from);

  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Velocity& default_instance();

  void Swap(Velocity* other);

  // implements Message ----------------------------------------------

  inline Velocity* New() const { return New(NULL); }

  Velocity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Velocity& from);
  void MergeFrom(const Velocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Velocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double v = 1 [default = 0];
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 1;
  double v() const;
  void set_v(double value);

  // required double w = 2 [default = 0];
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 2;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:stdmsg.Velocity)
 private:
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_w();
  inline void clear_has_w();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double v_;
  double w_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Velocity* default_instance_;
};
// -------------------------------------------------------------------

class Laser_Scan_Laser_Config : public ::google::protobuf::Message {
 public:
  Laser_Scan_Laser_Config();
  virtual ~Laser_Scan_Laser_Config();

  Laser_Scan_Laser_Config(const Laser_Scan_Laser_Config& from);

  inline Laser_Scan_Laser_Config& operator=(const Laser_Scan_Laser_Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Laser_Scan_Laser_Config& default_instance();

  void Swap(Laser_Scan_Laser_Config* other);

  // implements Message ----------------------------------------------

  inline Laser_Scan_Laser_Config* New() const { return New(NULL); }

  Laser_Scan_Laser_Config* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Laser_Scan_Laser_Config& from);
  void MergeFrom(const Laser_Scan_Laser_Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Laser_Scan_Laser_Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float angle_min = 1;
  bool has_angle_min() const;
  void clear_angle_min();
  static const int kAngleMinFieldNumber = 1;
  float angle_min() const;
  void set_angle_min(float value);

  // required float angle_max = 2;
  bool has_angle_max() const;
  void clear_angle_max();
  static const int kAngleMaxFieldNumber = 2;
  float angle_max() const;
  void set_angle_max(float value);

  // required float angle_increment = 3;
  bool has_angle_increment() const;
  void clear_angle_increment();
  static const int kAngleIncrementFieldNumber = 3;
  float angle_increment() const;
  void set_angle_increment(float value);

  // required float range_max = 5;
  bool has_range_max() const;
  void clear_range_max();
  static const int kRangeMaxFieldNumber = 5;
  float range_max() const;
  void set_range_max(float value);

  // @@protoc_insertion_point(class_scope:stdmsg.Laser_Scan.Laser_Config)
 private:
  inline void set_has_angle_min();
  inline void clear_has_angle_min();
  inline void set_has_angle_max();
  inline void clear_has_angle_max();
  inline void set_has_angle_increment();
  inline void clear_has_angle_increment();
  inline void set_has_range_max();
  inline void clear_has_range_max();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float angle_min_;
  float angle_max_;
  float angle_increment_;
  float range_max_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Laser_Scan_Laser_Config* default_instance_;
};
// -------------------------------------------------------------------

class Laser_Scan : public ::google::protobuf::Message {
 public:
  Laser_Scan();
  virtual ~Laser_Scan();

  Laser_Scan(const Laser_Scan& from);

  inline Laser_Scan& operator=(const Laser_Scan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Laser_Scan& default_instance();

  void Swap(Laser_Scan* other);

  // implements Message ----------------------------------------------

  inline Laser_Scan* New() const { return New(NULL); }

  Laser_Scan* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Laser_Scan& from);
  void MergeFrom(const Laser_Scan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Laser_Scan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Laser_Scan_Laser_Config Laser_Config;

  // accessors -------------------------------------------------------

  // required .stdmsg.Laser_Scan.Laser_Config config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::stdmsg::Laser_Scan_Laser_Config& config() const;
  ::stdmsg::Laser_Scan_Laser_Config* mutable_config();
  ::stdmsg::Laser_Scan_Laser_Config* release_config();
  void set_allocated_config(::stdmsg::Laser_Scan_Laser_Config* config);

  // repeated float ranges = 2;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 2;
  float ranges(int index) const;
  void set_ranges(int index, float value);
  void add_ranges(float value);
  const ::google::protobuf::RepeatedField< float >&
      ranges() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_ranges();

  // repeated float ranges_rssi = 10;
  int ranges_rssi_size() const;
  void clear_ranges_rssi();
  static const int kRangesRssiFieldNumber = 10;
  float ranges_rssi(int index) const;
  void set_ranges_rssi(int index, float value);
  void add_ranges_rssi(float value);
  const ::google::protobuf::RepeatedField< float >&
      ranges_rssi() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_ranges_rssi();

  // repeated float intensities = 3;
  int intensities_size() const;
  void clear_intensities();
  static const int kIntensitiesFieldNumber = 3;
  float intensities(int index) const;
  void set_intensities(int index, float value);
  void add_intensities(float value);
  const ::google::protobuf::RepeatedField< float >&
      intensities() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_intensities();

  // required .stdmsg.Pose pose = 5;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 5;
  const ::stdmsg::Pose& pose() const;
  ::stdmsg::Pose* mutable_pose();
  ::stdmsg::Pose* release_pose();
  void set_allocated_pose(::stdmsg::Pose* pose);

  // required .stdmsg.Pose robot = 6;
  bool has_robot() const;
  void clear_robot();
  static const int kRobotFieldNumber = 6;
  const ::stdmsg::Pose& robot() const;
  ::stdmsg::Pose* mutable_robot();
  ::stdmsg::Pose* release_robot();
  void set_allocated_robot(::stdmsg::Pose* robot);

  // optional double steer = 9;
  bool has_steer() const;
  void clear_steer();
  static const int kSteerFieldNumber = 9;
  double steer() const;
  void set_steer(double value);

  // optional int32 seq = 7 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 7;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // optional string annotation = 8 [default = ""];
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 8;
  const ::std::string& annotation() const;
  void set_annotation(const ::std::string& value);
  void set_annotation(const char* value);
  void set_annotation(const char* value, size_t size);
  ::std::string* mutable_annotation();
  ::std::string* release_annotation();
  void set_allocated_annotation(::std::string* annotation);

  // @@protoc_insertion_point(class_scope:stdmsg.Laser_Scan)
 private:
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_steer();
  inline void clear_has_steer();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_annotation();
  inline void clear_has_annotation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::stdmsg::Laser_Scan_Laser_Config* config_;
  ::google::protobuf::RepeatedField< float > ranges_;
  ::google::protobuf::RepeatedField< float > ranges_rssi_;
  ::google::protobuf::RepeatedField< float > intensities_;
  ::stdmsg::Pose* pose_;
  ::stdmsg::Pose* robot_;
  double steer_;
  ::google::protobuf::internal::ArenaStringPtr annotation_;
  ::google::protobuf::int32 seq_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Laser_Scan* default_instance_;
};
// -------------------------------------------------------------------

class Global_Plan : public ::google::protobuf::Message {
 public:
  Global_Plan();
  virtual ~Global_Plan();

  Global_Plan(const Global_Plan& from);

  inline Global_Plan& operator=(const Global_Plan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Global_Plan& default_instance();

  void Swap(Global_Plan* other);

  // implements Message ----------------------------------------------

  inline Global_Plan* New() const { return New(NULL); }

  Global_Plan* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Global_Plan& from);
  void MergeFrom(const Global_Plan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Global_Plan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .stdmsg.Pose path = 1;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::stdmsg::Pose& path(int index) const;
  ::stdmsg::Pose* mutable_path(int index);
  ::stdmsg::Pose* add_path();
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >*
      mutable_path();
  const ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >&
      path() const;

  // optional int32 seq = 2 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // optional int32 goal_reached = 3 [default = 0];
  bool has_goal_reached() const;
  void clear_goal_reached();
  static const int kGoalReachedFieldNumber = 3;
  ::google::protobuf::int32 goal_reached() const;
  void set_goal_reached(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.Global_Plan)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_goal_reached();
  inline void clear_has_goal_reached();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose > path_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::int32 goal_reached_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Global_Plan* default_instance_;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  inline Data* New() const { return New(NULL); }

  Data* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1 [default = ""];
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional int32 seq = 2 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.Data)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 seq_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// -------------------------------------------------------------------

class String : public ::google::protobuf::Message {
 public:
  String();
  virtual ~String();

  String(const String& from);

  inline String& operator=(const String& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const String& default_instance();

  void Swap(String* other);

  // implements Message ----------------------------------------------

  inline String* New() const { return New(NULL); }

  String* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const String& from);
  void MergeFrom(const String& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(String* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes str = 1 [default = ""];
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 1;
  const ::std::string& str() const;
  void set_str(const ::std::string& value);
  void set_str(const char* value);
  void set_str(const void* value, size_t size);
  ::std::string* mutable_str();
  ::std::string* release_str();
  void set_allocated_str(::std::string* str);

  // optional int32 seq = 2 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.String)
 private:
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr str_;
  ::google::protobuf::int32 seq_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static String* default_instance_;
};
// -------------------------------------------------------------------

class LaserList : public ::google::protobuf::Message {
 public:
  LaserList();
  virtual ~LaserList();

  LaserList(const LaserList& from);

  inline LaserList& operator=(const LaserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserList& default_instance();

  void Swap(LaserList* other);

  // implements Message ----------------------------------------------

  inline LaserList* New() const { return New(NULL); }

  LaserList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaserList& from);
  void MergeFrom(const LaserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .stdmsg.Laser_Scan scans = 1;
  int scans_size() const;
  void clear_scans();
  static const int kScansFieldNumber = 1;
  const ::stdmsg::Laser_Scan& scans(int index) const;
  ::stdmsg::Laser_Scan* mutable_scans(int index);
  ::stdmsg::Laser_Scan* add_scans();
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >*
      mutable_scans();
  const ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >&
      scans() const;

  // optional int32 seq = 2 [default = 0];
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:stdmsg.LaserList)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan > scans_;
  ::google::protobuf::int32 seq_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static LaserList* default_instance_;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  inline Block* New() const { return New(NULL); }

  Block* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated string input = 2;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  const ::std::string& input(int index) const;
  ::std::string* mutable_input(int index);
  void set_input(int index, const ::std::string& value);
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, size_t size);
  ::std::string* add_input();
  void add_input(const ::std::string& value);
  void add_input(const char* value);
  void add_input(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // repeated string input_type = 3;
  int input_type_size() const;
  void clear_input_type();
  static const int kInputTypeFieldNumber = 3;
  const ::std::string& input_type(int index) const;
  ::std::string* mutable_input_type(int index);
  void set_input_type(int index, const ::std::string& value);
  void set_input_type(int index, const char* value);
  void set_input_type(int index, const char* value, size_t size);
  ::std::string* add_input_type();
  void add_input_type(const ::std::string& value);
  void add_input_type(const char* value);
  void add_input_type(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& input_type() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input_type();

  // repeated string output = 4;
  int output_size() const;
  void clear_output();
  static const int kOutputFieldNumber = 4;
  const ::std::string& output(int index) const;
  ::std::string* mutable_output(int index);
  void set_output(int index, const ::std::string& value);
  void set_output(int index, const char* value);
  void set_output(int index, const char* value, size_t size);
  ::std::string* add_output();
  void add_output(const ::std::string& value);
  void add_output(const char* value);
  void add_output(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& output() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_output();

  // repeated string output_type = 5;
  int output_type_size() const;
  void clear_output_type();
  static const int kOutputTypeFieldNumber = 5;
  const ::std::string& output_type(int index) const;
  ::std::string* mutable_output_type(int index);
  void set_output_type(int index, const ::std::string& value);
  void set_output_type(int index, const char* value);
  void set_output_type(int index, const char* value, size_t size);
  ::std::string* add_output_type();
  void add_output_type(const ::std::string& value);
  void add_output_type(const char* value);
  void add_output_type(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& output_type() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_output_type();

  // required string dll = 6;
  bool has_dll() const;
  void clear_dll();
  static const int kDllFieldNumber = 6;
  const ::std::string& dll() const;
  void set_dll(const ::std::string& value);
  void set_dll(const char* value);
  void set_dll(const char* value, size_t size);
  ::std::string* mutable_dll();
  ::std::string* release_dll();
  void set_allocated_dll(::std::string* dll);

  // required string object = 7;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 7;
  const ::std::string& object() const;
  void set_object(const ::std::string& value);
  void set_object(const char* value);
  void set_object(const char* value, size_t size);
  ::std::string* mutable_object();
  ::std::string* release_object();
  void set_allocated_object(::std::string* object);

  // @@protoc_insertion_point(class_scope:stdmsg.Block)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_dll();
  inline void clear_has_dll();
  inline void set_has_object();
  inline void clear_has_object();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> output_;
  ::google::protobuf::RepeatedPtrField< ::std::string> output_type_;
  ::google::protobuf::internal::ArenaStringPtr dll_;
  ::google::protobuf::internal::ArenaStringPtr object_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Block* default_instance_;
};
// -------------------------------------------------------------------

class Net : public ::google::protobuf::Message {
 public:
  Net();
  virtual ~Net();

  Net(const Net& from);

  inline Net& operator=(const Net& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Net& default_instance();

  void Swap(Net* other);

  // implements Message ----------------------------------------------

  inline Net* New() const { return New(NULL); }

  Net* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Net& from);
  void MergeFrom(const Net& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Net* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .stdmsg.Block block = 1;
  int block_size() const;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  const ::stdmsg::Block& block(int index) const;
  ::stdmsg::Block* mutable_block(int index);
  ::stdmsg::Block* add_block();
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Block >*
      mutable_block();
  const ::google::protobuf::RepeatedPtrField< ::stdmsg::Block >&
      block() const;

  // @@protoc_insertion_point(class_scope:stdmsg.Net)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::stdmsg::Block > block_;
  friend void  protobuf_AddDesc_stdmsg_2eproto();
  friend void protobuf_AssignDesc_stdmsg_2eproto();
  friend void protobuf_ShutdownFile_stdmsg_2eproto();

  void InitAsDefaultInstance();
  static Net* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Position

// required double x = 1 [default = 0];
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Position::x() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.x)
  return x_;
}
inline void Position::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.x)
}

// required double y = 2 [default = 0];
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Position::y() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.y)
  return y_;
}
inline void Position::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.y)
}

// optional double z = 3 [default = 0];
inline bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Position::z() const {
  // @@protoc_insertion_point(field_get:stdmsg.Position.z)
  return z_;
}
inline void Position::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Position.z)
}

// -------------------------------------------------------------------

// Orentation

// optional double roll = 1 [default = 0];
inline bool Orentation::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Orentation::set_has_roll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Orentation::clear_has_roll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Orentation::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline double Orentation::roll() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.roll)
  return roll_;
}
inline void Orentation::set_roll(double value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.roll)
}

// optional double pitch = 2 [default = 0];
inline bool Orentation::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Orentation::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Orentation::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Orentation::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline double Orentation::pitch() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.pitch)
  return pitch_;
}
inline void Orentation::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.pitch)
}

// required double yaw = 3 [default = 0];
inline bool Orentation::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Orentation::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Orentation::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Orentation::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline double Orentation::yaw() const {
  // @@protoc_insertion_point(field_get:stdmsg.Orentation.yaw)
  return yaw_;
}
inline void Orentation::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Orentation.yaw)
}

// -------------------------------------------------------------------

// Pose

// required .stdmsg.Position position = 1;
inline bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_position() {
  if (position_ != NULL) position_->::stdmsg::Position::Clear();
  clear_has_position();
}
inline const ::stdmsg::Position& Pose::position() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::stdmsg::Position* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::stdmsg::Position;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Pose.position)
  return position_;
}
inline ::stdmsg::Position* Pose::release_position() {
  clear_has_position();
  ::stdmsg::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Pose::set_allocated_position(::stdmsg::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Pose.position)
}

// required .stdmsg.Orentation orentation = 2;
inline bool Pose::has_orentation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_orentation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_orentation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_orentation() {
  if (orentation_ != NULL) orentation_->::stdmsg::Orentation::Clear();
  clear_has_orentation();
}
inline const ::stdmsg::Orentation& Pose::orentation() const {
  // @@protoc_insertion_point(field_get:stdmsg.Pose.orentation)
  return orentation_ != NULL ? *orentation_ : *default_instance_->orentation_;
}
inline ::stdmsg::Orentation* Pose::mutable_orentation() {
  set_has_orentation();
  if (orentation_ == NULL) {
    orentation_ = new ::stdmsg::Orentation;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Pose.orentation)
  return orentation_;
}
inline ::stdmsg::Orentation* Pose::release_orentation() {
  clear_has_orentation();
  ::stdmsg::Orentation* temp = orentation_;
  orentation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_orentation(::stdmsg::Orentation* orentation) {
  delete orentation_;
  orentation_ = orentation;
  if (orentation) {
    set_has_orentation();
  } else {
    clear_has_orentation();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Pose.orentation)
}

// -------------------------------------------------------------------

// Velocity

// required double v = 1 [default = 0];
inline bool Velocity::has_v() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Velocity::set_has_v() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Velocity::clear_has_v() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Velocity::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline double Velocity::v() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.v)
  return v_;
}
inline void Velocity::set_v(double value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.v)
}

// required double w = 2 [default = 0];
inline bool Velocity::has_w() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Velocity::set_has_w() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Velocity::clear_has_w() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Velocity::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Velocity::w() const {
  // @@protoc_insertion_point(field_get:stdmsg.Velocity.w)
  return w_;
}
inline void Velocity::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Velocity.w)
}

// -------------------------------------------------------------------

// Laser_Scan_Laser_Config

// required float angle_min = 1;
inline bool Laser_Scan_Laser_Config::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Laser_Scan_Laser_Config::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Laser_Scan_Laser_Config::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
inline float Laser_Scan_Laser_Config::angle_min() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_min)
  return angle_min_;
}
inline void Laser_Scan_Laser_Config::set_angle_min(float value) {
  set_has_angle_min();
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_min)
}

// required float angle_max = 2;
inline bool Laser_Scan_Laser_Config::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Laser_Scan_Laser_Config::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Laser_Scan_Laser_Config::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
inline float Laser_Scan_Laser_Config::angle_max() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_max)
  return angle_max_;
}
inline void Laser_Scan_Laser_Config::set_angle_max(float value) {
  set_has_angle_max();
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_max)
}

// required float angle_increment = 3;
inline bool Laser_Scan_Laser_Config::has_angle_increment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_angle_increment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Laser_Scan_Laser_Config::clear_has_angle_increment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Laser_Scan_Laser_Config::clear_angle_increment() {
  angle_increment_ = 0;
  clear_has_angle_increment();
}
inline float Laser_Scan_Laser_Config::angle_increment() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.angle_increment)
  return angle_increment_;
}
inline void Laser_Scan_Laser_Config::set_angle_increment(float value) {
  set_has_angle_increment();
  angle_increment_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.angle_increment)
}

// required float range_max = 5;
inline bool Laser_Scan_Laser_Config::has_range_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Laser_Scan_Laser_Config::set_has_range_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Laser_Scan_Laser_Config::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Laser_Scan_Laser_Config::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
inline float Laser_Scan_Laser_Config::range_max() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.Laser_Config.range_max)
  return range_max_;
}
inline void Laser_Scan_Laser_Config::set_range_max(float value) {
  set_has_range_max();
  range_max_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.Laser_Config.range_max)
}

// -------------------------------------------------------------------

// Laser_Scan

// required .stdmsg.Laser_Scan.Laser_Config config = 1;
inline bool Laser_Scan::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Laser_Scan::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Laser_Scan::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Laser_Scan::clear_config() {
  if (config_ != NULL) config_->::stdmsg::Laser_Scan_Laser_Config::Clear();
  clear_has_config();
}
inline const ::stdmsg::Laser_Scan_Laser_Config& Laser_Scan::config() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::stdmsg::Laser_Scan_Laser_Config;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.config)
  return config_;
}
inline ::stdmsg::Laser_Scan_Laser_Config* Laser_Scan::release_config() {
  clear_has_config();
  ::stdmsg::Laser_Scan_Laser_Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline void Laser_Scan::set_allocated_config(::stdmsg::Laser_Scan_Laser_Config* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.config)
}

// repeated float ranges = 2;
inline int Laser_Scan::ranges_size() const {
  return ranges_.size();
}
inline void Laser_Scan::clear_ranges() {
  ranges_.Clear();
}
inline float Laser_Scan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.ranges)
  return ranges_.Get(index);
}
inline void Laser_Scan::set_ranges(int index, float value) {
  ranges_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.ranges)
}
inline void Laser_Scan::add_ranges(float value) {
  ranges_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.ranges)
}
inline const ::google::protobuf::RepeatedField< float >&
Laser_Scan::ranges() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.ranges)
  return ranges_;
}
inline ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.ranges)
  return &ranges_;
}

// repeated float ranges_rssi = 10;
inline int Laser_Scan::ranges_rssi_size() const {
  return ranges_rssi_.size();
}
inline void Laser_Scan::clear_ranges_rssi() {
  ranges_rssi_.Clear();
}
inline float Laser_Scan::ranges_rssi(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.ranges_rssi)
  return ranges_rssi_.Get(index);
}
inline void Laser_Scan::set_ranges_rssi(int index, float value) {
  ranges_rssi_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.ranges_rssi)
}
inline void Laser_Scan::add_ranges_rssi(float value) {
  ranges_rssi_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.ranges_rssi)
}
inline const ::google::protobuf::RepeatedField< float >&
Laser_Scan::ranges_rssi() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.ranges_rssi)
  return ranges_rssi_;
}
inline ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_ranges_rssi() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.ranges_rssi)
  return &ranges_rssi_;
}

// repeated float intensities = 3;
inline int Laser_Scan::intensities_size() const {
  return intensities_.size();
}
inline void Laser_Scan::clear_intensities() {
  intensities_.Clear();
}
inline float Laser_Scan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.intensities)
  return intensities_.Get(index);
}
inline void Laser_Scan::set_intensities(int index, float value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.intensities)
}
inline void Laser_Scan::add_intensities(float value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:stdmsg.Laser_Scan.intensities)
}
inline const ::google::protobuf::RepeatedField< float >&
Laser_Scan::intensities() const {
  // @@protoc_insertion_point(field_list:stdmsg.Laser_Scan.intensities)
  return intensities_;
}
inline ::google::protobuf::RepeatedField< float >*
Laser_Scan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Laser_Scan.intensities)
  return &intensities_;
}

// required .stdmsg.Pose pose = 5;
inline bool Laser_Scan::has_pose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Laser_Scan::set_has_pose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Laser_Scan::clear_has_pose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Laser_Scan::clear_pose() {
  if (pose_ != NULL) pose_->::stdmsg::Pose::Clear();
  clear_has_pose();
}
inline const ::stdmsg::Pose& Laser_Scan::pose() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::stdmsg::Pose* Laser_Scan::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::stdmsg::Pose;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.pose)
  return pose_;
}
inline ::stdmsg::Pose* Laser_Scan::release_pose() {
  clear_has_pose();
  ::stdmsg::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void Laser_Scan::set_allocated_pose(::stdmsg::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.pose)
}

// required .stdmsg.Pose robot = 6;
inline bool Laser_Scan::has_robot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Laser_Scan::set_has_robot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Laser_Scan::clear_has_robot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Laser_Scan::clear_robot() {
  if (robot_ != NULL) robot_->::stdmsg::Pose::Clear();
  clear_has_robot();
}
inline const ::stdmsg::Pose& Laser_Scan::robot() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.robot)
  return robot_ != NULL ? *robot_ : *default_instance_->robot_;
}
inline ::stdmsg::Pose* Laser_Scan::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    robot_ = new ::stdmsg::Pose;
  }
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.robot)
  return robot_;
}
inline ::stdmsg::Pose* Laser_Scan::release_robot() {
  clear_has_robot();
  ::stdmsg::Pose* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline void Laser_Scan::set_allocated_robot(::stdmsg::Pose* robot) {
  delete robot_;
  robot_ = robot;
  if (robot) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.robot)
}

// optional double steer = 9;
inline bool Laser_Scan::has_steer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Laser_Scan::set_has_steer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Laser_Scan::clear_has_steer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Laser_Scan::clear_steer() {
  steer_ = 0;
  clear_has_steer();
}
inline double Laser_Scan::steer() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.steer)
  return steer_;
}
inline void Laser_Scan::set_steer(double value) {
  set_has_steer();
  steer_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.steer)
}

// optional int32 seq = 7 [default = 0];
inline bool Laser_Scan::has_seq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Laser_Scan::set_has_seq() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Laser_Scan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Laser_Scan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 Laser_Scan::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.seq)
  return seq_;
}
inline void Laser_Scan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.seq)
}

// optional string annotation = 8 [default = ""];
inline bool Laser_Scan::has_annotation() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Laser_Scan::set_has_annotation() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Laser_Scan::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Laser_Scan::clear_annotation() {
  annotation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_annotation();
}
inline const ::std::string& Laser_Scan::annotation() const {
  // @@protoc_insertion_point(field_get:stdmsg.Laser_Scan.annotation)
  return annotation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Laser_Scan::set_annotation(const ::std::string& value) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Laser_Scan.annotation)
}
inline void Laser_Scan::set_annotation(const char* value) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Laser_Scan.annotation)
}
inline void Laser_Scan::set_annotation(const char* value, size_t size) {
  set_has_annotation();
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Laser_Scan.annotation)
}
inline ::std::string* Laser_Scan::mutable_annotation() {
  set_has_annotation();
  // @@protoc_insertion_point(field_mutable:stdmsg.Laser_Scan.annotation)
  return annotation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Laser_Scan::release_annotation() {
  clear_has_annotation();
  return annotation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Laser_Scan::set_allocated_annotation(::std::string* annotation) {
  if (annotation != NULL) {
    set_has_annotation();
  } else {
    clear_has_annotation();
  }
  annotation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), annotation);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Laser_Scan.annotation)
}

// -------------------------------------------------------------------

// Global_Plan

// repeated .stdmsg.Pose path = 1;
inline int Global_Plan::path_size() const {
  return path_.size();
}
inline void Global_Plan::clear_path() {
  path_.Clear();
}
inline const ::stdmsg::Pose& Global_Plan::path(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.path)
  return path_.Get(index);
}
inline ::stdmsg::Pose* Global_Plan::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Global_Plan.path)
  return path_.Mutable(index);
}
inline ::stdmsg::Pose* Global_Plan::add_path() {
  // @@protoc_insertion_point(field_add:stdmsg.Global_Plan.path)
  return path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >*
Global_Plan::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Global_Plan.path)
  return &path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::stdmsg::Pose >&
Global_Plan::path() const {
  // @@protoc_insertion_point(field_list:stdmsg.Global_Plan.path)
  return path_;
}

// optional int32 seq = 2 [default = 0];
inline bool Global_Plan::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Global_Plan::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Global_Plan::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Global_Plan::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 Global_Plan::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.seq)
  return seq_;
}
inline void Global_Plan::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.seq)
}

// optional int32 goal_reached = 3 [default = 0];
inline bool Global_Plan::has_goal_reached() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Global_Plan::set_has_goal_reached() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Global_Plan::clear_has_goal_reached() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Global_Plan::clear_goal_reached() {
  goal_reached_ = 0;
  clear_has_goal_reached();
}
inline ::google::protobuf::int32 Global_Plan::goal_reached() const {
  // @@protoc_insertion_point(field_get:stdmsg.Global_Plan.goal_reached)
  return goal_reached_;
}
inline void Global_Plan::set_goal_reached(::google::protobuf::int32 value) {
  set_has_goal_reached();
  goal_reached_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Global_Plan.goal_reached)
}

// -------------------------------------------------------------------

// Data

// optional bytes data = 1 [default = ""];
inline bool Data::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Data::data() const {
  // @@protoc_insertion_point(field_get:stdmsg.Data.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Data::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Data.data)
}
inline void Data::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Data.data)
}
inline void Data::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Data.data)
}
inline ::std::string* Data::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:stdmsg.Data.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Data::release_data() {
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Data::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Data.data)
}

// optional int32 seq = 2 [default = 0];
inline bool Data::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 Data::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.Data.seq)
  return seq_;
}
inline void Data::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.Data.seq)
}

// -------------------------------------------------------------------

// String

// optional bytes str = 1 [default = ""];
inline bool String::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void String::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void String::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void String::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_str();
}
inline const ::std::string& String::str() const {
  // @@protoc_insertion_point(field_get:stdmsg.String.str)
  return str_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void String::set_str(const ::std::string& value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.String.str)
}
inline void String::set_str(const char* value) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.String.str)
}
inline void String::set_str(const void* value, size_t size) {
  set_has_str();
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.String.str)
}
inline ::std::string* String::mutable_str() {
  set_has_str();
  // @@protoc_insertion_point(field_mutable:stdmsg.String.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* String::release_str() {
  clear_has_str();
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void String::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    set_has_str();
  } else {
    clear_has_str();
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.String.str)
}

// optional int32 seq = 2 [default = 0];
inline bool String::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void String::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void String::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void String::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 String::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.String.seq)
  return seq_;
}
inline void String::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.String.seq)
}

// -------------------------------------------------------------------

// LaserList

// repeated .stdmsg.Laser_Scan scans = 1;
inline int LaserList::scans_size() const {
  return scans_.size();
}
inline void LaserList::clear_scans() {
  scans_.Clear();
}
inline const ::stdmsg::Laser_Scan& LaserList::scans(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.LaserList.scans)
  return scans_.Get(index);
}
inline ::stdmsg::Laser_Scan* LaserList::mutable_scans(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.LaserList.scans)
  return scans_.Mutable(index);
}
inline ::stdmsg::Laser_Scan* LaserList::add_scans() {
  // @@protoc_insertion_point(field_add:stdmsg.LaserList.scans)
  return scans_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >*
LaserList::mutable_scans() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.LaserList.scans)
  return &scans_;
}
inline const ::google::protobuf::RepeatedPtrField< ::stdmsg::Laser_Scan >&
LaserList::scans() const {
  // @@protoc_insertion_point(field_list:stdmsg.LaserList.scans)
  return scans_;
}

// optional int32 seq = 2 [default = 0];
inline bool LaserList::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaserList::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaserList::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaserList::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 LaserList::seq() const {
  // @@protoc_insertion_point(field_get:stdmsg.LaserList.seq)
  return seq_;
}
inline void LaserList::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:stdmsg.LaserList.seq)
}

// -------------------------------------------------------------------

// Block

// required string name = 1;
inline bool Block::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Block::name() const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Block.name)
}
inline void Block::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.name)
}
inline void Block::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.name)
}
inline ::std::string* Block::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Block.name)
}

// repeated string input = 2;
inline int Block::input_size() const {
  return input_.size();
}
inline void Block::clear_input() {
  input_.Clear();
}
inline const ::std::string& Block::input(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.input)
  return input_.Get(index);
}
inline ::std::string* Block::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.input)
  return input_.Mutable(index);
}
inline void Block::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:stdmsg.Block.input)
  input_.Mutable(index)->assign(value);
}
inline void Block::set_input(int index, const char* value) {
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.input)
}
inline void Block::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.input)
}
inline ::std::string* Block::add_input() {
  return input_.Add();
}
inline void Block::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stdmsg.Block.input)
}
inline void Block::add_input(const char* value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stdmsg.Block.input)
}
inline void Block::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stdmsg.Block.input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::input() const {
  // @@protoc_insertion_point(field_list:stdmsg.Block.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Block.input)
  return &input_;
}

// repeated string input_type = 3;
inline int Block::input_type_size() const {
  return input_type_.size();
}
inline void Block::clear_input_type() {
  input_type_.Clear();
}
inline const ::std::string& Block::input_type(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.input_type)
  return input_type_.Get(index);
}
inline ::std::string* Block::mutable_input_type(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.input_type)
  return input_type_.Mutable(index);
}
inline void Block::set_input_type(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:stdmsg.Block.input_type)
  input_type_.Mutable(index)->assign(value);
}
inline void Block::set_input_type(int index, const char* value) {
  input_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.input_type)
}
inline void Block::set_input_type(int index, const char* value, size_t size) {
  input_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.input_type)
}
inline ::std::string* Block::add_input_type() {
  return input_type_.Add();
}
inline void Block::add_input_type(const ::std::string& value) {
  input_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stdmsg.Block.input_type)
}
inline void Block::add_input_type(const char* value) {
  input_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stdmsg.Block.input_type)
}
inline void Block::add_input_type(const char* value, size_t size) {
  input_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stdmsg.Block.input_type)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::input_type() const {
  // @@protoc_insertion_point(field_list:stdmsg.Block.input_type)
  return input_type_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_input_type() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Block.input_type)
  return &input_type_;
}

// repeated string output = 4;
inline int Block::output_size() const {
  return output_.size();
}
inline void Block::clear_output() {
  output_.Clear();
}
inline const ::std::string& Block::output(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.output)
  return output_.Get(index);
}
inline ::std::string* Block::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.output)
  return output_.Mutable(index);
}
inline void Block::set_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:stdmsg.Block.output)
  output_.Mutable(index)->assign(value);
}
inline void Block::set_output(int index, const char* value) {
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.output)
}
inline void Block::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.output)
}
inline ::std::string* Block::add_output() {
  return output_.Add();
}
inline void Block::add_output(const ::std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stdmsg.Block.output)
}
inline void Block::add_output(const char* value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stdmsg.Block.output)
}
inline void Block::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stdmsg.Block.output)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::output() const {
  // @@protoc_insertion_point(field_list:stdmsg.Block.output)
  return output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Block.output)
  return &output_;
}

// repeated string output_type = 5;
inline int Block::output_type_size() const {
  return output_type_.size();
}
inline void Block::clear_output_type() {
  output_type_.Clear();
}
inline const ::std::string& Block::output_type(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.output_type)
  return output_type_.Get(index);
}
inline ::std::string* Block::mutable_output_type(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.output_type)
  return output_type_.Mutable(index);
}
inline void Block::set_output_type(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:stdmsg.Block.output_type)
  output_type_.Mutable(index)->assign(value);
}
inline void Block::set_output_type(int index, const char* value) {
  output_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.output_type)
}
inline void Block::set_output_type(int index, const char* value, size_t size) {
  output_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.output_type)
}
inline ::std::string* Block::add_output_type() {
  return output_type_.Add();
}
inline void Block::add_output_type(const ::std::string& value) {
  output_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stdmsg.Block.output_type)
}
inline void Block::add_output_type(const char* value) {
  output_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stdmsg.Block.output_type)
}
inline void Block::add_output_type(const char* value, size_t size) {
  output_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stdmsg.Block.output_type)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Block::output_type() const {
  // @@protoc_insertion_point(field_list:stdmsg.Block.output_type)
  return output_type_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Block::mutable_output_type() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Block.output_type)
  return &output_type_;
}

// required string dll = 6;
inline bool Block::has_dll() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Block::set_has_dll() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Block::clear_has_dll() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Block::clear_dll() {
  dll_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dll();
}
inline const ::std::string& Block::dll() const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.dll)
  return dll_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_dll(const ::std::string& value) {
  set_has_dll();
  dll_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Block.dll)
}
inline void Block::set_dll(const char* value) {
  set_has_dll();
  dll_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.dll)
}
inline void Block::set_dll(const char* value, size_t size) {
  set_has_dll();
  dll_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.dll)
}
inline ::std::string* Block::mutable_dll() {
  set_has_dll();
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.dll)
  return dll_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_dll() {
  clear_has_dll();
  return dll_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_dll(::std::string* dll) {
  if (dll != NULL) {
    set_has_dll();
  } else {
    clear_has_dll();
  }
  dll_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dll);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Block.dll)
}

// required string object = 7;
inline bool Block::has_object() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Block::set_has_object() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Block::clear_has_object() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Block::clear_object() {
  object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object();
}
inline const ::std::string& Block::object() const {
  // @@protoc_insertion_point(field_get:stdmsg.Block.object)
  return object_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_object(const ::std::string& value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:stdmsg.Block.object)
}
inline void Block::set_object(const char* value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:stdmsg.Block.object)
}
inline void Block::set_object(const char* value, size_t size) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:stdmsg.Block.object)
}
inline ::std::string* Block::mutable_object() {
  set_has_object();
  // @@protoc_insertion_point(field_mutable:stdmsg.Block.object)
  return object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Block::release_object() {
  clear_has_object();
  return object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Block::set_allocated_object(::std::string* object) {
  if (object != NULL) {
    set_has_object();
  } else {
    clear_has_object();
  }
  object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object);
  // @@protoc_insertion_point(field_set_allocated:stdmsg.Block.object)
}

// -------------------------------------------------------------------

// Net

// repeated .stdmsg.Block block = 1;
inline int Net::block_size() const {
  return block_.size();
}
inline void Net::clear_block() {
  block_.Clear();
}
inline const ::stdmsg::Block& Net::block(int index) const {
  // @@protoc_insertion_point(field_get:stdmsg.Net.block)
  return block_.Get(index);
}
inline ::stdmsg::Block* Net::mutable_block(int index) {
  // @@protoc_insertion_point(field_mutable:stdmsg.Net.block)
  return block_.Mutable(index);
}
inline ::stdmsg::Block* Net::add_block() {
  // @@protoc_insertion_point(field_add:stdmsg.Net.block)
  return block_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::stdmsg::Block >*
Net::mutable_block() {
  // @@protoc_insertion_point(field_mutable_list:stdmsg.Net.block)
  return &block_;
}
inline const ::google::protobuf::RepeatedPtrField< ::stdmsg::Block >&
Net::block() const {
  // @@protoc_insertion_point(field_list:stdmsg.Net.block)
  return block_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace stdmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_stdmsg_2eproto__INCLUDED
